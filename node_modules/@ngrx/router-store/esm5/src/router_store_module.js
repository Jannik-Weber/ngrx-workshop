import * as tslib_1 from "tslib";
import { Inject, InjectionToken, NgModule, ErrorHandler, } from '@angular/core';
import { NavigationCancel, NavigationError, NavigationEnd, Router, RoutesRecognized, NavigationStart, } from '@angular/router';
import { select, Store } from '@ngrx/store';
import { withLatestFrom } from 'rxjs/operators';
import { ROUTER_CANCEL, ROUTER_ERROR, ROUTER_NAVIGATED, ROUTER_NAVIGATION, ROUTER_REQUEST, } from './actions';
import { RouterStateSerializer, } from './serializers/base';
import { DefaultRouterStateSerializer, } from './serializers/default_serializer';
import { MinimalRouterStateSerializer } from './serializers/minimal_serializer';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@ngrx/store';
import * as ɵngcc2 from '@angular/router';
export var NavigationActionTiming;
(function (NavigationActionTiming) {
    NavigationActionTiming[NavigationActionTiming["PreActivation"] = 1] = "PreActivation";
    NavigationActionTiming[NavigationActionTiming["PostActivation"] = 2] = "PostActivation";
})(NavigationActionTiming || (NavigationActionTiming = {}));
export var _ROUTER_CONFIG = new InjectionToken('@ngrx/router-store Internal Configuration');
export var ROUTER_CONFIG = new InjectionToken('@ngrx/router-store Configuration');
export var DEFAULT_ROUTER_FEATURENAME = 'router';
export function _createRouterConfig(config) {
    return tslib_1.__assign({ stateKey: DEFAULT_ROUTER_FEATURENAME, serializer: DefaultRouterStateSerializer, navigationActionTiming: NavigationActionTiming.PreActivation }, config);
}
var RouterTrigger;
(function (RouterTrigger) {
    RouterTrigger[RouterTrigger["NONE"] = 1] = "NONE";
    RouterTrigger[RouterTrigger["ROUTER"] = 2] = "ROUTER";
    RouterTrigger[RouterTrigger["STORE"] = 3] = "STORE";
})(RouterTrigger || (RouterTrigger = {}));
/**
 * Connects RouterModule with StoreModule.
 *
 * During the navigation, before any guards or resolvers run, the router will dispatch
 * a ROUTER_NAVIGATION action, which has the following signature:
 *
 * ```
 * export type RouterNavigationPayload = {
 *   routerState: SerializedRouterStateSnapshot,
 *   event: RoutesRecognized
 * }
 * ```
 *
 * Either a reducer or an effect can be invoked in response to this action.
 * If the invoked reducer throws, the navigation will be canceled.
 *
 * If navigation gets canceled because of a guard, a ROUTER_CANCEL action will be
 * dispatched. If navigation results in an error, a ROUTER_ERROR action will be dispatched.
 *
 * Both ROUTER_CANCEL and ROUTER_ERROR contain the store state before the navigation
 * which can be used to restore the consistency of the store.
 *
 * Usage:
 *
 * ```typescript
 * @NgModule({
 *   declarations: [AppCmp, SimpleCmp],
 *   imports: [
 *     BrowserModule,
 *     StoreModule.forRoot(mapOfReducers),
 *     RouterModule.forRoot([
 *       { path: '', component: SimpleCmp },
 *       { path: 'next', component: SimpleCmp }
 *     ]),
 *     StoreRouterConnectingModule.forRoot()
 *   ],
 *   bootstrap: [AppCmp]
 * })
 * export class AppModule {
 * }
 * ```
 */
var StoreRouterConnectingModule = /** @class */ (function () {
    function StoreRouterConnectingModule(store, router, serializer, errorHandler, config) {
        this.store = store;
        this.router = router;
        this.serializer = serializer;
        this.errorHandler = errorHandler;
        this.config = config;
        this.lastEvent = null;
        this.trigger = RouterTrigger.NONE;
        this.stateKey = this.config.stateKey;
        this.setUpStoreStateListener();
        this.setUpRouterEventsListener();
    }
    StoreRouterConnectingModule_1 = StoreRouterConnectingModule;
    StoreRouterConnectingModule.forRoot = function (config) {
        if (config === void 0) { config = {}; }
        return {
            ngModule: StoreRouterConnectingModule_1,
            providers: [
                { provide: _ROUTER_CONFIG, useValue: config },
                {
                    provide: ROUTER_CONFIG,
                    useFactory: _createRouterConfig,
                    deps: [_ROUTER_CONFIG],
                },
                {
                    provide: RouterStateSerializer,
                    useClass: config.serializer
                        ? config.serializer
                        : config.routerState === 1 /* Minimal */
                            ? MinimalRouterStateSerializer
                            : DefaultRouterStateSerializer,
                },
            ],
        };
    };
    StoreRouterConnectingModule.prototype.setUpStoreStateListener = function () {
        var _this = this;
        this.store
            .pipe(select(this.stateKey), withLatestFrom(this.store))
            .subscribe(function (_a) {
            var _b = tslib_1.__read(_a, 2), routerStoreState = _b[0], storeState = _b[1];
            _this.navigateIfNeeded(routerStoreState, storeState);
        });
    };
    StoreRouterConnectingModule.prototype.navigateIfNeeded = function (routerStoreState, storeState) {
        var _this = this;
        if (!routerStoreState || !routerStoreState.state) {
            return;
        }
        if (this.trigger === RouterTrigger.ROUTER) {
            return;
        }
        if (this.lastEvent instanceof NavigationStart) {
            return;
        }
        var url = routerStoreState.state.url;
        if (this.router.url !== url) {
            this.storeState = storeState;
            this.trigger = RouterTrigger.STORE;
            this.router.navigateByUrl(url).catch(function (error) {
                _this.errorHandler.handleError(error);
            });
        }
    };
    StoreRouterConnectingModule.prototype.setUpRouterEventsListener = function () {
        var _this = this;
        var dispatchNavLate = this.config.navigationActionTiming ===
            NavigationActionTiming.PostActivation;
        var routesRecognized;
        this.router.events
            .pipe(withLatestFrom(this.store))
            .subscribe(function (_a) {
            var _b = tslib_1.__read(_a, 2), event = _b[0], storeState = _b[1];
            _this.lastEvent = event;
            if (event instanceof NavigationStart) {
                _this.routerState = _this.serializer.serialize(_this.router.routerState.snapshot);
                if (_this.trigger !== RouterTrigger.STORE) {
                    _this.storeState = storeState;
                    _this.dispatchRouterRequest(event);
                }
            }
            else if (event instanceof RoutesRecognized) {
                routesRecognized = event;
                if (!dispatchNavLate && _this.trigger !== RouterTrigger.STORE) {
                    _this.dispatchRouterNavigation(event);
                }
            }
            else if (event instanceof NavigationCancel) {
                _this.dispatchRouterCancel(event);
                _this.reset();
            }
            else if (event instanceof NavigationError) {
                _this.dispatchRouterError(event);
                _this.reset();
            }
            else if (event instanceof NavigationEnd) {
                if (_this.trigger !== RouterTrigger.STORE) {
                    if (dispatchNavLate) {
                        _this.dispatchRouterNavigation(routesRecognized);
                    }
                    _this.dispatchRouterNavigated(event);
                }
                _this.reset();
            }
        });
    };
    StoreRouterConnectingModule.prototype.dispatchRouterRequest = function (event) {
        this.dispatchRouterAction(ROUTER_REQUEST, { event: event });
    };
    StoreRouterConnectingModule.prototype.dispatchRouterNavigation = function (lastRoutesRecognized) {
        var nextRouterState = this.serializer.serialize(lastRoutesRecognized.state);
        this.dispatchRouterAction(ROUTER_NAVIGATION, {
            routerState: nextRouterState,
            event: new RoutesRecognized(lastRoutesRecognized.id, lastRoutesRecognized.url, lastRoutesRecognized.urlAfterRedirects, nextRouterState),
        });
    };
    StoreRouterConnectingModule.prototype.dispatchRouterCancel = function (event) {
        this.dispatchRouterAction(ROUTER_CANCEL, {
            storeState: this.storeState,
            event: event,
        });
    };
    StoreRouterConnectingModule.prototype.dispatchRouterError = function (event) {
        this.dispatchRouterAction(ROUTER_ERROR, {
            storeState: this.storeState,
            event: new NavigationError(event.id, event.url, "" + event),
        });
    };
    StoreRouterConnectingModule.prototype.dispatchRouterNavigated = function (event) {
        var routerState = this.serializer.serialize(this.router.routerState.snapshot);
        this.dispatchRouterAction(ROUTER_NAVIGATED, { event: event, routerState: routerState });
    };
    StoreRouterConnectingModule.prototype.dispatchRouterAction = function (type, payload) {
        this.trigger = RouterTrigger.ROUTER;
        try {
            this.store.dispatch({
                type: type,
                payload: tslib_1.__assign({ routerState: this.routerState }, payload, { event: this.config.routerState === 1 /* Minimal */
                        ? { id: payload.event.id, url: payload.event.url }
                        : payload.event }),
            });
        }
        finally {
            this.trigger = RouterTrigger.NONE;
        }
    };
    StoreRouterConnectingModule.prototype.reset = function () {
        this.trigger = RouterTrigger.NONE;
        this.storeState = null;
        this.routerState = null;
    };
    var StoreRouterConnectingModule_1;
    StoreRouterConnectingModule = StoreRouterConnectingModule_1 = tslib_1.__decorate([ tslib_1.__param(4, Inject(ROUTER_CONFIG)),
        tslib_1.__metadata("design:paramtypes", [Store,
            Router,
            RouterStateSerializer,
            ErrorHandler, Object])
    ], StoreRouterConnectingModule);
StoreRouterConnectingModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: StoreRouterConnectingModule });
StoreRouterConnectingModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function StoreRouterConnectingModule_Factory(t) { return new (t || StoreRouterConnectingModule)(ɵngcc0.ɵɵinject(ɵngcc1.Store), ɵngcc0.ɵɵinject(ɵngcc2.Router), ɵngcc0.ɵɵinject(RouterStateSerializer), ɵngcc0.ɵɵinject(ɵngcc0.ErrorHandler), ɵngcc0.ɵɵinject(ROUTER_CONFIG)); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StoreRouterConnectingModule, [{
        type: NgModule,
        args: [{}]
    }], function () { return [{ type: ɵngcc1.Store }, { type: ɵngcc2.Router }, { type: RouterStateSerializer }, { type: ɵngcc0.ErrorHandler }, { type: Object, decorators: [{
                type: Inject,
                args: [ROUTER_CONFIG]
            }] }]; }, null); })();
    return StoreRouterConnectingModule;
}());
export { StoreRouterConnectingModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkQ6L2Jhay9iZXJhdHVuZy9hbmd1bGFyMi93b3Jrc2hvcHNfYWR2YW5jZWQvYWR2YW5jZWQtbngtd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbmdyeC9yb3V0ZXItc3RvcmUvZXNtNS9zcmMvcm91dGVyX3N0b3JlX21vZHVsZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NGQW9Oc0YsQUFFL0U7Ozs7Ozs7Ozs7Ozs7O2tDQUs2QiIsImZpbGUiOiJyb3V0ZXJfc3RvcmVfbW9kdWxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IEluamVjdCwgSW5qZWN0aW9uVG9rZW4sIE5nTW9kdWxlLCBFcnJvckhhbmRsZXIsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uQ2FuY2VsLCBOYXZpZ2F0aW9uRXJyb3IsIE5hdmlnYXRpb25FbmQsIFJvdXRlciwgUm91dGVzUmVjb2duaXplZCwgTmF2aWdhdGlvblN0YXJ0LCB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBzZWxlY3QsIFN0b3JlIH0gZnJvbSAnQG5ncngvc3RvcmUnO1xuaW1wb3J0IHsgd2l0aExhdGVzdEZyb20gfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBST1VURVJfQ0FOQ0VMLCBST1VURVJfRVJST1IsIFJPVVRFUl9OQVZJR0FURUQsIFJPVVRFUl9OQVZJR0FUSU9OLCBST1VURVJfUkVRVUVTVCwgfSBmcm9tICcuL2FjdGlvbnMnO1xuaW1wb3J0IHsgUm91dGVyU3RhdGVTZXJpYWxpemVyLCB9IGZyb20gJy4vc2VyaWFsaXplcnMvYmFzZSc7XG5pbXBvcnQgeyBEZWZhdWx0Um91dGVyU3RhdGVTZXJpYWxpemVyLCB9IGZyb20gJy4vc2VyaWFsaXplcnMvZGVmYXVsdF9zZXJpYWxpemVyJztcbmltcG9ydCB7IE1pbmltYWxSb3V0ZXJTdGF0ZVNlcmlhbGl6ZXIgfSBmcm9tICcuL3NlcmlhbGl6ZXJzL21pbmltYWxfc2VyaWFsaXplcic7XG5leHBvcnQgdmFyIE5hdmlnYXRpb25BY3Rpb25UaW1pbmc7XG4oZnVuY3Rpb24gKE5hdmlnYXRpb25BY3Rpb25UaW1pbmcpIHtcbiAgICBOYXZpZ2F0aW9uQWN0aW9uVGltaW5nW05hdmlnYXRpb25BY3Rpb25UaW1pbmdbXCJQcmVBY3RpdmF0aW9uXCJdID0gMV0gPSBcIlByZUFjdGl2YXRpb25cIjtcbiAgICBOYXZpZ2F0aW9uQWN0aW9uVGltaW5nW05hdmlnYXRpb25BY3Rpb25UaW1pbmdbXCJQb3N0QWN0aXZhdGlvblwiXSA9IDJdID0gXCJQb3N0QWN0aXZhdGlvblwiO1xufSkoTmF2aWdhdGlvbkFjdGlvblRpbWluZyB8fCAoTmF2aWdhdGlvbkFjdGlvblRpbWluZyA9IHt9KSk7XG5leHBvcnQgdmFyIF9ST1VURVJfQ09ORklHID0gbmV3IEluamVjdGlvblRva2VuKCdAbmdyeC9yb3V0ZXItc3RvcmUgSW50ZXJuYWwgQ29uZmlndXJhdGlvbicpO1xuZXhwb3J0IHZhciBST1VURVJfQ09ORklHID0gbmV3IEluamVjdGlvblRva2VuKCdAbmdyeC9yb3V0ZXItc3RvcmUgQ29uZmlndXJhdGlvbicpO1xuZXhwb3J0IHZhciBERUZBVUxUX1JPVVRFUl9GRUFUVVJFTkFNRSA9ICdyb3V0ZXInO1xuZXhwb3J0IGZ1bmN0aW9uIF9jcmVhdGVSb3V0ZXJDb25maWcoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRzbGliXzEuX19hc3NpZ24oeyBzdGF0ZUtleTogREVGQVVMVF9ST1VURVJfRkVBVFVSRU5BTUUsIHNlcmlhbGl6ZXI6IERlZmF1bHRSb3V0ZXJTdGF0ZVNlcmlhbGl6ZXIsIG5hdmlnYXRpb25BY3Rpb25UaW1pbmc6IE5hdmlnYXRpb25BY3Rpb25UaW1pbmcuUHJlQWN0aXZhdGlvbiB9LCBjb25maWcpO1xufVxudmFyIFJvdXRlclRyaWdnZXI7XG4oZnVuY3Rpb24gKFJvdXRlclRyaWdnZXIpIHtcbiAgICBSb3V0ZXJUcmlnZ2VyW1JvdXRlclRyaWdnZXJbXCJOT05FXCJdID0gMV0gPSBcIk5PTkVcIjtcbiAgICBSb3V0ZXJUcmlnZ2VyW1JvdXRlclRyaWdnZXJbXCJST1VURVJcIl0gPSAyXSA9IFwiUk9VVEVSXCI7XG4gICAgUm91dGVyVHJpZ2dlcltSb3V0ZXJUcmlnZ2VyW1wiU1RPUkVcIl0gPSAzXSA9IFwiU1RPUkVcIjtcbn0pKFJvdXRlclRyaWdnZXIgfHwgKFJvdXRlclRyaWdnZXIgPSB7fSkpO1xuLyoqXG4gKiBDb25uZWN0cyBSb3V0ZXJNb2R1bGUgd2l0aCBTdG9yZU1vZHVsZS5cbiAqXG4gKiBEdXJpbmcgdGhlIG5hdmlnYXRpb24sIGJlZm9yZSBhbnkgZ3VhcmRzIG9yIHJlc29sdmVycyBydW4sIHRoZSByb3V0ZXIgd2lsbCBkaXNwYXRjaFxuICogYSBST1VURVJfTkFWSUdBVElPTiBhY3Rpb24sIHdoaWNoIGhhcyB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZTpcbiAqXG4gKiBgYGBcbiAqIGV4cG9ydCB0eXBlIFJvdXRlck5hdmlnYXRpb25QYXlsb2FkID0ge1xuICogICByb3V0ZXJTdGF0ZTogU2VyaWFsaXplZFJvdXRlclN0YXRlU25hcHNob3QsXG4gKiAgIGV2ZW50OiBSb3V0ZXNSZWNvZ25pemVkXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBFaXRoZXIgYSByZWR1Y2VyIG9yIGFuIGVmZmVjdCBjYW4gYmUgaW52b2tlZCBpbiByZXNwb25zZSB0byB0aGlzIGFjdGlvbi5cbiAqIElmIHRoZSBpbnZva2VkIHJlZHVjZXIgdGhyb3dzLCB0aGUgbmF2aWdhdGlvbiB3aWxsIGJlIGNhbmNlbGVkLlxuICpcbiAqIElmIG5hdmlnYXRpb24gZ2V0cyBjYW5jZWxlZCBiZWNhdXNlIG9mIGEgZ3VhcmQsIGEgUk9VVEVSX0NBTkNFTCBhY3Rpb24gd2lsbCBiZVxuICogZGlzcGF0Y2hlZC4gSWYgbmF2aWdhdGlvbiByZXN1bHRzIGluIGFuIGVycm9yLCBhIFJPVVRFUl9FUlJPUiBhY3Rpb24gd2lsbCBiZSBkaXNwYXRjaGVkLlxuICpcbiAqIEJvdGggUk9VVEVSX0NBTkNFTCBhbmQgUk9VVEVSX0VSUk9SIGNvbnRhaW4gdGhlIHN0b3JlIHN0YXRlIGJlZm9yZSB0aGUgbmF2aWdhdGlvblxuICogd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmVzdG9yZSB0aGUgY29uc2lzdGVuY3kgb2YgdGhlIHN0b3JlLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGRlY2xhcmF0aW9uczogW0FwcENtcCwgU2ltcGxlQ21wXSxcbiAqICAgaW1wb3J0czogW1xuICogICAgIEJyb3dzZXJNb2R1bGUsXG4gKiAgICAgU3RvcmVNb2R1bGUuZm9yUm9vdChtYXBPZlJlZHVjZXJzKSxcbiAqICAgICBSb3V0ZXJNb2R1bGUuZm9yUm9vdChbXG4gKiAgICAgICB7IHBhdGg6ICcnLCBjb21wb25lbnQ6IFNpbXBsZUNtcCB9LFxuICogICAgICAgeyBwYXRoOiAnbmV4dCcsIGNvbXBvbmVudDogU2ltcGxlQ21wIH1cbiAqICAgICBdKSxcbiAqICAgICBTdG9yZVJvdXRlckNvbm5lY3RpbmdNb2R1bGUuZm9yUm9vdCgpXG4gKiAgIF0sXG4gKiAgIGJvb3RzdHJhcDogW0FwcENtcF1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHtcbiAqIH1cbiAqIGBgYFxuICovXG52YXIgU3RvcmVSb3V0ZXJDb25uZWN0aW5nTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0b3JlUm91dGVyQ29ubmVjdGluZ01vZHVsZShzdG9yZSwgcm91dGVyLCBzZXJpYWxpemVyLCBlcnJvckhhbmRsZXIsIGNvbmZpZykge1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmU7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBzZXJpYWxpemVyO1xuICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMubGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmlnZ2VyID0gUm91dGVyVHJpZ2dlci5OT05FO1xuICAgICAgICB0aGlzLnN0YXRlS2V5ID0gdGhpcy5jb25maWcuc3RhdGVLZXk7XG4gICAgICAgIHRoaXMuc2V0VXBTdG9yZVN0YXRlTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXRVcFJvdXRlckV2ZW50c0xpc3RlbmVyKCk7XG4gICAgfVxuICAgIFN0b3JlUm91dGVyQ29ubmVjdGluZ01vZHVsZV8xID0gU3RvcmVSb3V0ZXJDb25uZWN0aW5nTW9kdWxlO1xuICAgIFN0b3JlUm91dGVyQ29ubmVjdGluZ01vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBTdG9yZVJvdXRlckNvbm5lY3RpbmdNb2R1bGVfMSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogX1JPVVRFUl9DT05GSUcsIHVzZVZhbHVlOiBjb25maWcgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IFJPVVRFUl9DT05GSUcsXG4gICAgICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IF9jcmVhdGVSb3V0ZXJDb25maWcsXG4gICAgICAgICAgICAgICAgICAgIGRlcHM6IFtfUk9VVEVSX0NPTkZJR10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IFJvdXRlclN0YXRlU2VyaWFsaXplcixcbiAgICAgICAgICAgICAgICAgICAgdXNlQ2xhc3M6IGNvbmZpZy5zZXJpYWxpemVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbmZpZy5zZXJpYWxpemVyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNvbmZpZy5yb3V0ZXJTdGF0ZSA9PT0gMSAvKiBNaW5pbWFsICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBNaW5pbWFsUm91dGVyU3RhdGVTZXJpYWxpemVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBEZWZhdWx0Um91dGVyU3RhdGVTZXJpYWxpemVyLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgU3RvcmVSb3V0ZXJDb25uZWN0aW5nTW9kdWxlLnByb3RvdHlwZS5zZXRVcFN0b3JlU3RhdGVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdG9yZVxuICAgICAgICAgICAgLnBpcGUoc2VsZWN0KHRoaXMuc3RhdGVLZXkpLCB3aXRoTGF0ZXN0RnJvbSh0aGlzLnN0b3JlKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSB0c2xpYl8xLl9fcmVhZChfYSwgMiksIHJvdXRlclN0b3JlU3RhdGUgPSBfYlswXSwgc3RvcmVTdGF0ZSA9IF9iWzFdO1xuICAgICAgICAgICAgX3RoaXMubmF2aWdhdGVJZk5lZWRlZChyb3V0ZXJTdG9yZVN0YXRlLCBzdG9yZVN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdG9yZVJvdXRlckNvbm5lY3RpbmdNb2R1bGUucHJvdG90eXBlLm5hdmlnYXRlSWZOZWVkZWQgPSBmdW5jdGlvbiAocm91dGVyU3RvcmVTdGF0ZSwgc3RvcmVTdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXJvdXRlclN0b3JlU3RhdGUgfHwgIXJvdXRlclN0b3JlU3RhdGUuc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmlnZ2VyID09PSBSb3V0ZXJUcmlnZ2VyLlJPVVRFUikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxhc3RFdmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25TdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cmwgPSByb3V0ZXJTdG9yZVN0YXRlLnN0YXRlLnVybDtcbiAgICAgICAgaWYgKHRoaXMucm91dGVyLnVybCAhPT0gdXJsKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JlU3RhdGUgPSBzdG9yZVN0YXRlO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyID0gUm91dGVyVHJpZ2dlci5TVE9SRTtcbiAgICAgICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlQnlVcmwodXJsKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lcnJvckhhbmRsZXIuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0b3JlUm91dGVyQ29ubmVjdGluZ01vZHVsZS5wcm90b3R5cGUuc2V0VXBSb3V0ZXJFdmVudHNMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGRpc3BhdGNoTmF2TGF0ZSA9IHRoaXMuY29uZmlnLm5hdmlnYXRpb25BY3Rpb25UaW1pbmcgPT09XG4gICAgICAgICAgICBOYXZpZ2F0aW9uQWN0aW9uVGltaW5nLlBvc3RBY3RpdmF0aW9uO1xuICAgICAgICB2YXIgcm91dGVzUmVjb2duaXplZDtcbiAgICAgICAgdGhpcy5yb3V0ZXIuZXZlbnRzXG4gICAgICAgICAgICAucGlwZSh3aXRoTGF0ZXN0RnJvbSh0aGlzLnN0b3JlKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSB0c2xpYl8xLl9fcmVhZChfYSwgMiksIGV2ZW50ID0gX2JbMF0sIHN0b3JlU3RhdGUgPSBfYlsxXTtcbiAgICAgICAgICAgIF90aGlzLmxhc3RFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucm91dGVyU3RhdGUgPSBfdGhpcy5zZXJpYWxpemVyLnNlcmlhbGl6ZShfdGhpcy5yb3V0ZXIucm91dGVyU3RhdGUuc25hcHNob3QpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy50cmlnZ2VyICE9PSBSb3V0ZXJUcmlnZ2VyLlNUT1JFKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0b3JlU3RhdGUgPSBzdG9yZVN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaFJvdXRlclJlcXVlc3QoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50IGluc3RhbmNlb2YgUm91dGVzUmVjb2duaXplZCkge1xuICAgICAgICAgICAgICAgIHJvdXRlc1JlY29nbml6ZWQgPSBldmVudDtcbiAgICAgICAgICAgICAgICBpZiAoIWRpc3BhdGNoTmF2TGF0ZSAmJiBfdGhpcy50cmlnZ2VyICE9PSBSb3V0ZXJUcmlnZ2VyLlNUT1JFKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoUm91dGVyTmF2aWdhdGlvbihldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uQ2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2hSb3V0ZXJDYW5jZWwoZXZlbnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoUm91dGVyRXJyb3IoZXZlbnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMudHJpZ2dlciAhPT0gUm91dGVyVHJpZ2dlci5TVE9SRSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzcGF0Y2hOYXZMYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaFJvdXRlck5hdmlnYXRpb24ocm91dGVzUmVjb2duaXplZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2hSb3V0ZXJOYXZpZ2F0ZWQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0b3JlUm91dGVyQ29ubmVjdGluZ01vZHVsZS5wcm90b3R5cGUuZGlzcGF0Y2hSb3V0ZXJSZXF1ZXN0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hSb3V0ZXJBY3Rpb24oUk9VVEVSX1JFUVVFU1QsIHsgZXZlbnQ6IGV2ZW50IH0pO1xuICAgIH07XG4gICAgU3RvcmVSb3V0ZXJDb25uZWN0aW5nTW9kdWxlLnByb3RvdHlwZS5kaXNwYXRjaFJvdXRlck5hdmlnYXRpb24gPSBmdW5jdGlvbiAobGFzdFJvdXRlc1JlY29nbml6ZWQpIHtcbiAgICAgICAgdmFyIG5leHRSb3V0ZXJTdGF0ZSA9IHRoaXMuc2VyaWFsaXplci5zZXJpYWxpemUobGFzdFJvdXRlc1JlY29nbml6ZWQuc3RhdGUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoUm91dGVyQWN0aW9uKFJPVVRFUl9OQVZJR0FUSU9OLCB7XG4gICAgICAgICAgICByb3V0ZXJTdGF0ZTogbmV4dFJvdXRlclN0YXRlLFxuICAgICAgICAgICAgZXZlbnQ6IG5ldyBSb3V0ZXNSZWNvZ25pemVkKGxhc3RSb3V0ZXNSZWNvZ25pemVkLmlkLCBsYXN0Um91dGVzUmVjb2duaXplZC51cmwsIGxhc3RSb3V0ZXNSZWNvZ25pemVkLnVybEFmdGVyUmVkaXJlY3RzLCBuZXh0Um91dGVyU3RhdGUpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0b3JlUm91dGVyQ29ubmVjdGluZ01vZHVsZS5wcm90b3R5cGUuZGlzcGF0Y2hSb3V0ZXJDYW5jZWwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFJvdXRlckFjdGlvbihST1VURVJfQ0FOQ0VMLCB7XG4gICAgICAgICAgICBzdG9yZVN0YXRlOiB0aGlzLnN0b3JlU3RhdGUsXG4gICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RvcmVSb3V0ZXJDb25uZWN0aW5nTW9kdWxlLnByb3RvdHlwZS5kaXNwYXRjaFJvdXRlckVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hSb3V0ZXJBY3Rpb24oUk9VVEVSX0VSUk9SLCB7XG4gICAgICAgICAgICBzdG9yZVN0YXRlOiB0aGlzLnN0b3JlU3RhdGUsXG4gICAgICAgICAgICBldmVudDogbmV3IE5hdmlnYXRpb25FcnJvcihldmVudC5pZCwgZXZlbnQudXJsLCBcIlwiICsgZXZlbnQpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0b3JlUm91dGVyQ29ubmVjdGluZ01vZHVsZS5wcm90b3R5cGUuZGlzcGF0Y2hSb3V0ZXJOYXZpZ2F0ZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHJvdXRlclN0YXRlID0gdGhpcy5zZXJpYWxpemVyLnNlcmlhbGl6ZSh0aGlzLnJvdXRlci5yb3V0ZXJTdGF0ZS5zbmFwc2hvdCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hSb3V0ZXJBY3Rpb24oUk9VVEVSX05BVklHQVRFRCwgeyBldmVudDogZXZlbnQsIHJvdXRlclN0YXRlOiByb3V0ZXJTdGF0ZSB9KTtcbiAgICB9O1xuICAgIFN0b3JlUm91dGVyQ29ubmVjdGluZ01vZHVsZS5wcm90b3R5cGUuZGlzcGF0Y2hSb3V0ZXJBY3Rpb24gPSBmdW5jdGlvbiAodHlwZSwgcGF5bG9hZCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIgPSBSb3V0ZXJUcmlnZ2VyLlJPVVRFUjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogdHNsaWJfMS5fX2Fzc2lnbih7IHJvdXRlclN0YXRlOiB0aGlzLnJvdXRlclN0YXRlIH0sIHBheWxvYWQsIHsgZXZlbnQ6IHRoaXMuY29uZmlnLnJvdXRlclN0YXRlID09PSAxIC8qIE1pbmltYWwgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBpZDogcGF5bG9hZC5ldmVudC5pZCwgdXJsOiBwYXlsb2FkLmV2ZW50LnVybCB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBheWxvYWQuZXZlbnQgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlciA9IFJvdXRlclRyaWdnZXIuTk9ORTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmVSb3V0ZXJDb25uZWN0aW5nTW9kdWxlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyID0gUm91dGVyVHJpZ2dlci5OT05FO1xuICAgICAgICB0aGlzLnN0b3JlU3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnJvdXRlclN0YXRlID0gbnVsbDtcbiAgICB9O1xuICAgIHZhciBTdG9yZVJvdXRlckNvbm5lY3RpbmdNb2R1bGVfMTtcbiAgICBTdG9yZVJvdXRlckNvbm5lY3RpbmdNb2R1bGUgPSBTdG9yZVJvdXRlckNvbm5lY3RpbmdNb2R1bGVfMSA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgICAgIE5nTW9kdWxlKHt9KSxcbiAgICAgICAgdHNsaWJfMS5fX3BhcmFtKDQsIEluamVjdChST1VURVJfQ09ORklHKSksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdG9yZSxcbiAgICAgICAgICAgIFJvdXRlcixcbiAgICAgICAgICAgIFJvdXRlclN0YXRlU2VyaWFsaXplcixcbiAgICAgICAgICAgIEVycm9ySGFuZGxlciwgT2JqZWN0XSlcbiAgICBdLCBTdG9yZVJvdXRlckNvbm5lY3RpbmdNb2R1bGUpO1xuICAgIHJldHVybiBTdG9yZVJvdXRlckNvbm5lY3RpbmdNb2R1bGU7XG59KCkpO1xuZXhwb3J0IHsgU3RvcmVSb3V0ZXJDb25uZWN0aW5nTW9kdWxlIH07XG4iXX0=