import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { distinctUntilChanged, map, pluck } from 'rxjs/operators';
import { ActionsSubject } from './actions_subject';
import { ReducerManager } from './reducer_manager';
import { StateObservable } from './state';
import * as ɵngcc0 from '@angular/core';
var Store = /** @class */ (function (_super) {
    tslib_1.__extends(Store, _super);
    function Store(state$, actionsObserver, reducerManager) {
        var _this = _super.call(this) || this;
        _this.actionsObserver = actionsObserver;
        _this.reducerManager = reducerManager;
        _this.source = state$;
        return _this;
    }
    Store_1 = Store;
    Store.prototype.select = function (pathOrMapFn) {
        var _a;
        var paths = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            paths[_i - 1] = arguments[_i];
        }
        return (_a = select).call.apply(_a, tslib_1.__spread([null, pathOrMapFn], paths))(this);
    };
    Store.prototype.lift = function (operator) {
        var store = new Store_1(this, this.actionsObserver, this.reducerManager);
        store.operator = operator;
        return store;
    };
    Store.prototype.dispatch = function (action) {
        this.actionsObserver.next(action);
    };
    Store.prototype.next = function (action) {
        this.actionsObserver.next(action);
    };
    Store.prototype.error = function (err) {
        this.actionsObserver.error(err);
    };
    Store.prototype.complete = function () {
        this.actionsObserver.complete();
    };
    Store.prototype.addReducer = function (key, reducer) {
        this.reducerManager.addReducer(key, reducer);
    };
    Store.prototype.removeReducer = function (key) {
        this.reducerManager.removeReducer(key);
    };
    var Store_1;
    Store = Store_1 = tslib_1.__decorate([ tslib_1.__metadata("design:paramtypes", [StateObservable,
            ActionsSubject,
            ReducerManager])
    ], Store);
Store.ɵfac = function Store_Factory(t) { return new (t || Store)(ɵngcc0.ɵɵinject(StateObservable), ɵngcc0.ɵɵinject(ActionsSubject), ɵngcc0.ɵɵinject(ReducerManager)); };
Store.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: Store, factory: function (t) { return Store.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Store, [{
        type: Injectable
    }], function () { return [{ type: StateObservable }, { type: ActionsSubject }, { type: ReducerManager }]; }, null); })();
    return Store;
}(Observable));
export { Store };
export var STORE_PROVIDERS = [Store];
export function select(pathOrMapFn, propsOrPath) {
    var paths = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        paths[_i - 2] = arguments[_i];
    }
    return function selectOperator(source$) {
        var mapped$;
        if (typeof pathOrMapFn === 'string') {
            var pathSlices = tslib_1.__spread([propsOrPath], paths).filter(Boolean);
            mapped$ = source$.pipe(pluck.apply(void 0, tslib_1.__spread([pathOrMapFn], pathSlices)));
        }
        else if (typeof pathOrMapFn === 'function') {
            mapped$ = source$.pipe(map(function (source) { return pathOrMapFn(source, propsOrPath); }));
        }
        else {
            throw new TypeError("Unexpected type '" + typeof pathOrMapFn + "' in select operator," +
                " expected 'string' or 'function'");
        }
        return mapped$.pipe(distinctUntilChanged());
    };
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkQ6L2Jhay9iZXJhdHVuZy9hbmd1bGFyMi93b3Jrc2hvcHNfYWR2YW5jZWQvYWR2YW5jZWQtbngtd29ya3NwYWNlL25vZGVfbW9kdWxlcy9AbmdyeC9zdG9yZS9lc201L3NyYy9zdG9yZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBDQTBDMEMsQUFFbkM7Ozs7Ozs7OzZIQUdPIiwiZmlsZSI6InN0b3JlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBtYXAsIHBsdWNrIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQWN0aW9uc1N1YmplY3QgfSBmcm9tICcuL2FjdGlvbnNfc3ViamVjdCc7XG5pbXBvcnQgeyBSZWR1Y2VyTWFuYWdlciB9IGZyb20gJy4vcmVkdWNlcl9tYW5hZ2VyJztcbmltcG9ydCB7IFN0YXRlT2JzZXJ2YWJsZSB9IGZyb20gJy4vc3RhdGUnO1xudmFyIFN0b3JlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFN0b3JlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0b3JlKHN0YXRlJCwgYWN0aW9uc09ic2VydmVyLCByZWR1Y2VyTWFuYWdlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hY3Rpb25zT2JzZXJ2ZXIgPSBhY3Rpb25zT2JzZXJ2ZXI7XG4gICAgICAgIF90aGlzLnJlZHVjZXJNYW5hZ2VyID0gcmVkdWNlck1hbmFnZXI7XG4gICAgICAgIF90aGlzLnNvdXJjZSA9IHN0YXRlJDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdG9yZV8xID0gU3RvcmU7XG4gICAgU3RvcmUucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChwYXRoT3JNYXBGbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBwYXRocyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgcGF0aHNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChfYSA9IHNlbGVjdCkuY2FsbC5hcHBseShfYSwgdHNsaWJfMS5fX3NwcmVhZChbbnVsbCwgcGF0aE9yTWFwRm5dLCBwYXRocykpKHRoaXMpO1xuICAgIH07XG4gICAgU3RvcmUucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIHN0b3JlID0gbmV3IFN0b3JlXzEodGhpcywgdGhpcy5hY3Rpb25zT2JzZXJ2ZXIsIHRoaXMucmVkdWNlck1hbmFnZXIpO1xuICAgICAgICBzdG9yZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICByZXR1cm4gc3RvcmU7XG4gICAgfTtcbiAgICBTdG9yZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuYWN0aW9uc09ic2VydmVyLm5leHQoYWN0aW9uKTtcbiAgICB9O1xuICAgIFN0b3JlLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB0aGlzLmFjdGlvbnNPYnNlcnZlci5uZXh0KGFjdGlvbik7XG4gICAgfTtcbiAgICBTdG9yZS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuYWN0aW9uc09ic2VydmVyLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBTdG9yZS5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aW9uc09ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBTdG9yZS5wcm90b3R5cGUuYWRkUmVkdWNlciA9IGZ1bmN0aW9uIChrZXksIHJlZHVjZXIpIHtcbiAgICAgICAgdGhpcy5yZWR1Y2VyTWFuYWdlci5hZGRSZWR1Y2VyKGtleSwgcmVkdWNlcik7XG4gICAgfTtcbiAgICBTdG9yZS5wcm90b3R5cGUucmVtb3ZlUmVkdWNlciA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdGhpcy5yZWR1Y2VyTWFuYWdlci5yZW1vdmVSZWR1Y2VyKGtleSk7XG4gICAgfTtcbiAgICB2YXIgU3RvcmVfMTtcbiAgICBTdG9yZSA9IFN0b3JlXzEgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgICAgICBJbmplY3RhYmxlKCksXG4gICAgICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdGF0ZU9ic2VydmFibGUsXG4gICAgICAgICAgICBBY3Rpb25zU3ViamVjdCxcbiAgICAgICAgICAgIFJlZHVjZXJNYW5hZ2VyXSlcbiAgICBdLCBTdG9yZSk7XG4gICAgcmV0dXJuIFN0b3JlO1xufShPYnNlcnZhYmxlKSk7XG5leHBvcnQgeyBTdG9yZSB9O1xuZXhwb3J0IHZhciBTVE9SRV9QUk9WSURFUlMgPSBbU3RvcmVdO1xuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdChwYXRoT3JNYXBGbiwgcHJvcHNPclBhdGgpIHtcbiAgICB2YXIgcGF0aHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBwYXRoc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNlbGVjdE9wZXJhdG9yKHNvdXJjZSQpIHtcbiAgICAgICAgdmFyIG1hcHBlZCQ7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aE9yTWFwRm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgcGF0aFNsaWNlcyA9IHRzbGliXzEuX19zcHJlYWQoW3Byb3BzT3JQYXRoXSwgcGF0aHMpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgICAgIG1hcHBlZCQgPSBzb3VyY2UkLnBpcGUocGx1Y2suYXBwbHkodm9pZCAwLCB0c2xpYl8xLl9fc3ByZWFkKFtwYXRoT3JNYXBGbl0sIHBhdGhTbGljZXMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhdGhPck1hcEZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXBwZWQkID0gc291cmNlJC5waXBlKG1hcChmdW5jdGlvbiAoc291cmNlKSB7IHJldHVybiBwYXRoT3JNYXBGbihzb3VyY2UsIHByb3BzT3JQYXRoKTsgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgdHlwZSAnXCIgKyB0eXBlb2YgcGF0aE9yTWFwRm4gKyBcIicgaW4gc2VsZWN0IG9wZXJhdG9yLFwiICtcbiAgICAgICAgICAgICAgICBcIiBleHBlY3RlZCAnc3RyaW5nJyBvciAnZnVuY3Rpb24nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwZWQkLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG4gICAgfTtcbn1cbiJdfQ==