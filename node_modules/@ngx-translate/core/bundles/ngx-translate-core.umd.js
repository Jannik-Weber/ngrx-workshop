(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),exports, require('@angular/core'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@ngx-translate/core', ['@angular/core','exports', '@angular/core', 'rxjs', 'rxjs/operators'], factory) :
    (factory(global.ng.core,(global['ngx-translate'] = global['ngx-translate'] || {}, global['ngx-translate'].core = {}),global.ng.core,global.rxjs,global.rxjs.operators));
}(this, (function (ɵngcc0,exports,core,rxjs,operators) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ TranslateLoader = /** @class */ (function () {
        function TranslateLoader() {
        }
        return TranslateLoader;
    }());
    /**
     * This loader is just a placeholder that does nothing, in case you don't need a loader at all
     */
    var TranslateFakeLoader = /** @class */ (function (_super) {
        __extends(TranslateFakeLoader, _super);
        function TranslateFakeLoader() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?} lang
         * @return {?}
         */
        TranslateFakeLoader.prototype.getTranslation = /**
         * @param {?} lang
         * @return {?}
         */
            function (lang) {
                return rxjs.of({});
            };
TranslateFakeLoader.ɵfac = function TranslateFakeLoader_Factory(t) { return ɵTranslateFakeLoader_BaseFactory(t || TranslateFakeLoader); };
TranslateFakeLoader.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TranslateFakeLoader, factory: function (t) { return TranslateFakeLoader.ɵfac(t); } });
var ɵTranslateFakeLoader_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TranslateFakeLoader);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TranslateFakeLoader, [{
        type: core.Injectable
    }], null, null); })();
        return TranslateFakeLoader;
    }(TranslateLoader));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ MissingTranslationHandler = /** @class */ (function () {
        function MissingTranslationHandler() {
        }
        return MissingTranslationHandler;
    }());
    /**
     * This handler is just a placeholder that does nothing, in case you don't need a missing translation handler at all
     */
    var FakeMissingTranslationHandler = /** @class */ (function () {
        function FakeMissingTranslationHandler() {
        }
        /**
         * @param {?} params
         * @return {?}
         */
        FakeMissingTranslationHandler.prototype.handle = /**
         * @param {?} params
         * @return {?}
         */
            function (params) {
                return params.key;
            };
FakeMissingTranslationHandler.ɵfac = function FakeMissingTranslationHandler_Factory(t) { return new (t || FakeMissingTranslationHandler)(); };
FakeMissingTranslationHandler.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: FakeMissingTranslationHandler, factory: function (t) { return FakeMissingTranslationHandler.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FakeMissingTranslationHandler, [{
        type: core.Injectable
    }], function () { return []; }, null); })();
        return FakeMissingTranslationHandler;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ TranslateCompiler = /** @class */ (function () {
        function TranslateCompiler() {
        }
        return TranslateCompiler;
    }());
    /**
     * This compiler is just a placeholder that does nothing, in case you don't need a compiler at all
     */
    var TranslateFakeCompiler = /** @class */ (function (_super) {
        __extends(TranslateFakeCompiler, _super);
        function TranslateFakeCompiler() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?} value
         * @param {?} lang
         * @return {?}
         */
        TranslateFakeCompiler.prototype.compile = /**
         * @param {?} value
         * @param {?} lang
         * @return {?}
         */
            function (value, lang) {
                return value;
            };
        /**
         * @param {?} translations
         * @param {?} lang
         * @return {?}
         */
        TranslateFakeCompiler.prototype.compileTranslations = /**
         * @param {?} translations
         * @param {?} lang
         * @return {?}
         */
            function (translations, lang) {
                return translations;
            };
TranslateFakeCompiler.ɵfac = function TranslateFakeCompiler_Factory(t) { return ɵTranslateFakeCompiler_BaseFactory(t || TranslateFakeCompiler); };
TranslateFakeCompiler.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TranslateFakeCompiler, factory: function (t) { return TranslateFakeCompiler.ɵfac(t); } });
var ɵTranslateFakeCompiler_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TranslateFakeCompiler);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TranslateFakeCompiler, [{
        type: core.Injectable
    }], null, null); })();
        return TranslateFakeCompiler;
    }(TranslateCompiler));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /* tslint:disable */
    /**
     * Determines if two objects or two values are equivalent.
     *
     * Two objects or values are considered equivalent if at least one of the following is true:
     *
     * * Both objects or values pass `===` comparison.
     * * Both objects or values are of the same type and all of their properties are equal by
     *   comparing them with `equals`.
     *
     * @param {?} o1 Object or value to compare.
     * @param {?} o2 Object or value to compare.
     * @return {?} true if arguments are equal.
     */
    function equals(o1, o2) {
        if (o1 === o2)
            return true;
        if (o1 === null || o2 === null)
            return false;
        if (o1 !== o1 && o2 !== o2)
            return true; // NaN === NaN
        // NaN === NaN
        /** @type {?} */
        var t1 = typeof o1;
        /** @type {?} */
        var t2 = typeof o2;
        /** @type {?} */
        var length;
        /** @type {?} */
        var key;
        /** @type {?} */
        var keySet;
        if (t1 == t2 && t1 == 'object') {
            if (Array.isArray(o1)) {
                if (!Array.isArray(o2))
                    return false;
                if ((length = o1.length) == o2.length) {
                    for (key = 0; key < length; key++) {
                        if (!equals(o1[key], o2[key]))
                            return false;
                    }
                    return true;
                }
            }
            else {
                if (Array.isArray(o2)) {
                    return false;
                }
                keySet = Object.create(null);
                for (key in o1) {
                    if (!equals(o1[key], o2[key])) {
                        return false;
                    }
                    keySet[key] = true;
                }
                for (key in o2) {
                    if (!(key in keySet) && typeof o2[key] !== 'undefined') {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    }
    /* tslint:enable */
    /**
     * @param {?} value
     * @return {?}
     */
    function isDefined(value) {
        return typeof value !== 'undefined' && value !== null;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    function isObject(item) {
        return (item && typeof item === 'object' && !Array.isArray(item));
    }
    /**
     * @param {?} target
     * @param {?} source
     * @return {?}
     */
    function mergeDeep(target, source) {
        /** @type {?} */
        var output = Object.assign({}, target);
        if (isObject(target) && isObject(source)) {
            Object.keys(source).forEach(function (key) {
                var _a, _b;
                if (isObject(source[key])) {
                    if (!(key in target)) {
                        Object.assign(output, (_a = {}, _a[key] = source[key], _a));
                    }
                    else {
                        output[key] = mergeDeep(target[key], source[key]);
                    }
                }
                else {
                    Object.assign(output, (_b = {}, _b[key] = source[key], _b));
                }
            });
        }
        return output;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ TranslateParser = /** @class */ (function () {
        function TranslateParser() {
        }
        return TranslateParser;
    }());
    var TranslateDefaultParser = /** @class */ (function (_super) {
        __extends(TranslateDefaultParser, _super);
        function TranslateDefaultParser() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.templateMatcher = /{{\s?([^{}\s]*)\s?}}/g;
            return _this;
        }
        /**
         * @param {?} expr
         * @param {?=} params
         * @return {?}
         */
        TranslateDefaultParser.prototype.interpolate = /**
         * @param {?} expr
         * @param {?=} params
         * @return {?}
         */
            function (expr, params) {
                /** @type {?} */
                var result;
                if (typeof expr === 'string') {
                    result = this.interpolateString(expr, params);
                }
                else if (typeof expr === 'function') {
                    result = this.interpolateFunction(expr, params);
                }
                else {
                    // this should not happen, but an unrelated TranslateService test depends on it
                    result = ( /** @type {?} */(expr));
                }
                return result;
            };
        /**
         * @param {?} target
         * @param {?} key
         * @return {?}
         */
        TranslateDefaultParser.prototype.getValue = /**
         * @param {?} target
         * @param {?} key
         * @return {?}
         */
            function (target, key) {
                /** @type {?} */
                var keys = key.split('.');
                key = '';
                do {
                    key += keys.shift();
                    if (isDefined(target) && isDefined(target[key]) && (typeof target[key] === 'object' || !keys.length)) {
                        target = target[key];
                        key = '';
                    }
                    else if (!keys.length) {
                        target = undefined;
                    }
                    else {
                        key += '.';
                    }
                } while (keys.length);
                return target;
            };
        /**
         * @param {?} fn
         * @param {?=} params
         * @return {?}
         */
        TranslateDefaultParser.prototype.interpolateFunction = /**
         * @param {?} fn
         * @param {?=} params
         * @return {?}
         */
            function (fn, params) {
                return fn(params);
            };
        /**
         * @param {?} expr
         * @param {?=} params
         * @return {?}
         */
        TranslateDefaultParser.prototype.interpolateString = /**
         * @param {?} expr
         * @param {?=} params
         * @return {?}
         */
            function (expr, params) {
                var _this = this;
                if (!params) {
                    return expr;
                }
                return expr.replace(this.templateMatcher, function (substring, b) {
                    /** @type {?} */
                    var r = _this.getValue(params, b);
                    return isDefined(r) ? r : substring;
                });
            };
TranslateDefaultParser.ɵfac = function TranslateDefaultParser_Factory(t) { return ɵTranslateDefaultParser_BaseFactory(t || TranslateDefaultParser); };
TranslateDefaultParser.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TranslateDefaultParser, factory: function (t) { return TranslateDefaultParser.ɵfac(t); } });
var ɵTranslateDefaultParser_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(TranslateDefaultParser);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TranslateDefaultParser, [{
        type: core.Injectable
    }], null, null); })();
        return TranslateDefaultParser;
    }(TranslateParser));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var TranslateStore = /** @class */ (function () {
        function TranslateStore() {
            /**
             * The lang currently used
             */
            this.currentLang = this.defaultLang;
            /**
             * a list of translations per lang
             */
            this.translations = {};
            /**
             * an array of langs
             */
            this.langs = [];
            /**
             * An EventEmitter to listen to translation change events
             * onTranslationChange.subscribe((params: TranslationChangeEvent) => {
             *     // do something
             * });
             */
            this.onTranslationChange = new core.EventEmitter();
            /**
             * An EventEmitter to listen to lang change events
             * onLangChange.subscribe((params: LangChangeEvent) => {
             *     // do something
             * });
             */
            this.onLangChange = new core.EventEmitter();
            /**
             * An EventEmitter to listen to default lang change events
             * onDefaultLangChange.subscribe((params: DefaultLangChangeEvent) => {
             *     // do something
             * });
             */
            this.onDefaultLangChange = new core.EventEmitter();
        }
        return TranslateStore;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var USE_STORE = new core.InjectionToken('USE_STORE');
    /** @type {?} */
    var USE_DEFAULT_LANG = new core.InjectionToken('USE_DEFAULT_LANG');
    var TranslateService = /** @class */ (function () {
        /**
         *
         * @param store an instance of the store (that is supposed to be unique)
         * @param currentLoader An instance of the loader currently used
         * @param compiler An instance of the compiler currently used
         * @param parser An instance of the parser currently used
         * @param missingTranslationHandler A handler for missing translations.
         * @param isolate whether this service should use the store or not
         * @param useDefaultLang whether we should use default language translation when current language translation is missing.
         */
        function TranslateService(store, currentLoader, compiler, parser, missingTranslationHandler, useDefaultLang, isolate) {
            if (useDefaultLang === void 0) {
                useDefaultLang = true;
            }
            if (isolate === void 0) {
                isolate = false;
            }
            this.store = store;
            this.currentLoader = currentLoader;
            this.compiler = compiler;
            this.parser = parser;
            this.missingTranslationHandler = missingTranslationHandler;
            this.useDefaultLang = useDefaultLang;
            this.isolate = isolate;
            this.pending = false;
            this._onTranslationChange = new core.EventEmitter();
            this._onLangChange = new core.EventEmitter();
            this._onDefaultLangChange = new core.EventEmitter();
            this._langs = [];
            this._translations = {};
            this._translationRequests = {};
        }
        Object.defineProperty(TranslateService.prototype, "onTranslationChange", {
            /**
             * An EventEmitter to listen to translation change events
             * onTranslationChange.subscribe((params: TranslationChangeEvent) => {
               *     // do something
               * });
             */
            get: /**
             * An EventEmitter to listen to translation change events
             * onTranslationChange.subscribe((params: TranslationChangeEvent) => {
             *     // do something
             * });
             * @return {?}
             */ function () {
                return this.isolate ? this._onTranslationChange : this.store.onTranslationChange;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TranslateService.prototype, "onLangChange", {
            /**
             * An EventEmitter to listen to lang change events
             * onLangChange.subscribe((params: LangChangeEvent) => {
               *     // do something
               * });
             */
            get: /**
             * An EventEmitter to listen to lang change events
             * onLangChange.subscribe((params: LangChangeEvent) => {
             *     // do something
             * });
             * @return {?}
             */ function () {
                return this.isolate ? this._onLangChange : this.store.onLangChange;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TranslateService.prototype, "onDefaultLangChange", {
            /**
             * An EventEmitter to listen to default lang change events
             * onDefaultLangChange.subscribe((params: DefaultLangChangeEvent) => {
               *     // do something
               * });
             */
            get: /**
             * An EventEmitter to listen to default lang change events
             * onDefaultLangChange.subscribe((params: DefaultLangChangeEvent) => {
             *     // do something
             * });
             * @return {?}
             */ function () {
                return this.isolate ? this._onDefaultLangChange : this.store.onDefaultLangChange;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TranslateService.prototype, "defaultLang", {
            /**
             * The default lang to fallback when translations are missing on the current lang
             */
            get: /**
             * The default lang to fallback when translations are missing on the current lang
             * @return {?}
             */ function () {
                return this.isolate ? this._defaultLang : this.store.defaultLang;
            },
            set: /**
             * @param {?} defaultLang
             * @return {?}
             */ function (defaultLang) {
                if (this.isolate) {
                    this._defaultLang = defaultLang;
                }
                else {
                    this.store.defaultLang = defaultLang;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TranslateService.prototype, "currentLang", {
            /**
             * The lang currently used
             */
            get: /**
             * The lang currently used
             * @return {?}
             */ function () {
                return this.isolate ? this._currentLang : this.store.currentLang;
            },
            set: /**
             * @param {?} currentLang
             * @return {?}
             */ function (currentLang) {
                if (this.isolate) {
                    this._currentLang = currentLang;
                }
                else {
                    this.store.currentLang = currentLang;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TranslateService.prototype, "langs", {
            /**
             * an array of langs
             */
            get: /**
             * an array of langs
             * @return {?}
             */ function () {
                return this.isolate ? this._langs : this.store.langs;
            },
            set: /**
             * @param {?} langs
             * @return {?}
             */ function (langs) {
                if (this.isolate) {
                    this._langs = langs;
                }
                else {
                    this.store.langs = langs;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TranslateService.prototype, "translations", {
            /**
             * a list of translations per lang
             */
            get: /**
             * a list of translations per lang
             * @return {?}
             */ function () {
                return this.isolate ? this._translations : this.store.translations;
            },
            set: /**
             * @param {?} translations
             * @return {?}
             */ function (translations) {
                if (this.isolate) {
                    this._translations = translations;
                }
                else {
                    this.store.translations = translations;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets the default language to use as a fallback
         */
        /**
         * Sets the default language to use as a fallback
         * @param {?} lang
         * @return {?}
         */
        TranslateService.prototype.setDefaultLang = /**
         * Sets the default language to use as a fallback
         * @param {?} lang
         * @return {?}
         */
            function (lang) {
                var _this = this;
                if (lang === this.defaultLang) {
                    return;
                }
                /** @type {?} */
                var pending = this.retrieveTranslations(lang);
                if (typeof pending !== "undefined") {
                    // on init set the defaultLang immediately
                    if (!this.defaultLang) {
                        this.defaultLang = lang;
                    }
                    pending.pipe(operators.take(1))
                        .subscribe(function (res) {
                        _this.changeDefaultLang(lang);
                    });
                }
                else { // we already have this language
                    this.changeDefaultLang(lang);
                }
            };
        /**
         * Gets the default language used
         */
        /**
         * Gets the default language used
         * @return {?}
         */
        TranslateService.prototype.getDefaultLang = /**
         * Gets the default language used
         * @return {?}
         */
            function () {
                return this.defaultLang;
            };
        /**
         * Changes the lang currently used
         */
        /**
         * Changes the lang currently used
         * @param {?} lang
         * @return {?}
         */
        TranslateService.prototype.use = /**
         * Changes the lang currently used
         * @param {?} lang
         * @return {?}
         */
            function (lang) {
                var _this = this;
                // don't change the language if the language given is already selected
                if (lang === this.currentLang) {
                    return rxjs.of(this.translations[lang]);
                }
                /** @type {?} */
                var pending = this.retrieveTranslations(lang);
                if (typeof pending !== "undefined") {
                    // on init set the currentLang immediately
                    if (!this.currentLang) {
                        this.currentLang = lang;
                    }
                    pending.pipe(operators.take(1))
                        .subscribe(function (res) {
                        _this.changeLang(lang);
                    });
                    return pending;
                }
                else { // we have this language, return an Observable
                    this.changeLang(lang);
                    return rxjs.of(this.translations[lang]);
                }
            };
        /**
         * Retrieves the given translations
         */
        /**
         * Retrieves the given translations
         * @param {?} lang
         * @return {?}
         */
        TranslateService.prototype.retrieveTranslations = /**
         * Retrieves the given translations
         * @param {?} lang
         * @return {?}
         */
            function (lang) {
                /** @type {?} */
                var pending;
                // if this language is unavailable, ask for it
                if (typeof this.translations[lang] === "undefined") {
                    this._translationRequests[lang] = this._translationRequests[lang] || this.getTranslation(lang);
                    pending = this._translationRequests[lang];
                }
                return pending;
            };
        /**
         * Gets an object of translations for a given language with the current loader
         * and passes it through the compiler
         */
        /**
         * Gets an object of translations for a given language with the current loader
         * and passes it through the compiler
         * @param {?} lang
         * @return {?}
         */
        TranslateService.prototype.getTranslation = /**
         * Gets an object of translations for a given language with the current loader
         * and passes it through the compiler
         * @param {?} lang
         * @return {?}
         */
            function (lang) {
                var _this = this;
                this.pending = true;
                /** @type {?} */
                var loadingTranslations = this.currentLoader.getTranslation(lang).pipe(operators.share());
                this.loadingTranslations = loadingTranslations.pipe(operators.take(1), operators.map(function (res) { return _this.compiler.compileTranslations(res, lang); }), operators.share());
                this.loadingTranslations
                    .subscribe(function (res) {
                    _this.translations[lang] = res;
                    _this.updateLangs();
                    _this.pending = false;
                }, function (err) {
                    _this.pending = false;
                });
                return loadingTranslations;
            };
        /**
         * Manually sets an object of translations for a given language
         * after passing it through the compiler
         */
        /**
         * Manually sets an object of translations for a given language
         * after passing it through the compiler
         * @param {?} lang
         * @param {?} translations
         * @param {?=} shouldMerge
         * @return {?}
         */
        TranslateService.prototype.setTranslation = /**
         * Manually sets an object of translations for a given language
         * after passing it through the compiler
         * @param {?} lang
         * @param {?} translations
         * @param {?=} shouldMerge
         * @return {?}
         */
            function (lang, translations, shouldMerge) {
                if (shouldMerge === void 0) {
                    shouldMerge = false;
                }
                translations = this.compiler.compileTranslations(translations, lang);
                if (shouldMerge && this.translations[lang]) {
                    this.translations[lang] = mergeDeep(this.translations[lang], translations);
                }
                else {
                    this.translations[lang] = translations;
                }
                this.updateLangs();
                this.onTranslationChange.emit({ lang: lang, translations: this.translations[lang] });
            };
        /**
         * Returns an array of currently available langs
         */
        /**
         * Returns an array of currently available langs
         * @return {?}
         */
        TranslateService.prototype.getLangs = /**
         * Returns an array of currently available langs
         * @return {?}
         */
            function () {
                return this.langs;
            };
        /**
         * Add available langs
         */
        /**
         * Add available langs
         * @param {?} langs
         * @return {?}
         */
        TranslateService.prototype.addLangs = /**
         * Add available langs
         * @param {?} langs
         * @return {?}
         */
            function (langs) {
                var _this = this;
                langs.forEach(function (lang) {
                    if (_this.langs.indexOf(lang) === -1) {
                        _this.langs.push(lang);
                    }
                });
            };
        /**
         * Update the list of available langs
         */
        /**
         * Update the list of available langs
         * @return {?}
         */
        TranslateService.prototype.updateLangs = /**
         * Update the list of available langs
         * @return {?}
         */
            function () {
                this.addLangs(Object.keys(this.translations));
            };
        /**
         * Returns the parsed result of the translations
         */
        /**
         * Returns the parsed result of the translations
         * @param {?} translations
         * @param {?} key
         * @param {?=} interpolateParams
         * @return {?}
         */
        TranslateService.prototype.getParsedResult = /**
         * Returns the parsed result of the translations
         * @param {?} translations
         * @param {?} key
         * @param {?=} interpolateParams
         * @return {?}
         */
            function (translations, key, interpolateParams) {
                var e_1, _a, e_2, _b;
                /** @type {?} */
                var res;
                if (key instanceof Array) {
                    /** @type {?} */
                    var result = {};
                    /** @type {?} */
                    var observables = false;
                    try {
                        for (var key_1 = __values(key), key_1_1 = key_1.next(); !key_1_1.done; key_1_1 = key_1.next()) {
                            var k = key_1_1.value;
                            result[k] = this.getParsedResult(translations, k, interpolateParams);
                            if (typeof result[k].subscribe === "function") {
                                observables = true;
                            }
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (key_1_1 && !key_1_1.done && (_a = key_1.return))
                                _a.call(key_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    if (observables) {
                        /** @type {?} */
                        var mergedObs = void 0;
                        try {
                            for (var key_2 = __values(key), key_2_1 = key_2.next(); !key_2_1.done; key_2_1 = key_2.next()) {
                                var k = key_2_1.value;
                                /** @type {?} */
                                var obs = typeof result[k].subscribe === "function" ? result[k] : rxjs.of(( /** @type {?} */(result[k])));
                                if (typeof mergedObs === "undefined") {
                                    mergedObs = obs;
                                }
                                else {
                                    mergedObs = rxjs.merge(mergedObs, obs);
                                }
                            }
                        }
                        catch (e_2_1) {
                            e_2 = { error: e_2_1 };
                        }
                        finally {
                            try {
                                if (key_2_1 && !key_2_1.done && (_b = key_2.return))
                                    _b.call(key_2);
                            }
                            finally {
                                if (e_2)
                                    throw e_2.error;
                            }
                        }
                        return mergedObs.pipe(operators.toArray(), operators.map(function (arr) {
                            /** @type {?} */
                            var obj = {};
                            arr.forEach(function (value, index) {
                                obj[key[index]] = value;
                            });
                            return obj;
                        }));
                    }
                    return result;
                }
                if (translations) {
                    res = this.parser.interpolate(this.parser.getValue(translations, key), interpolateParams);
                }
                if (typeof res === "undefined" && this.defaultLang && this.defaultLang !== this.currentLang && this.useDefaultLang) {
                    res = this.parser.interpolate(this.parser.getValue(this.translations[this.defaultLang], key), interpolateParams);
                }
                if (typeof res === "undefined") {
                    /** @type {?} */
                    var params = { key: key, translateService: this };
                    if (typeof interpolateParams !== 'undefined') {
                        params.interpolateParams = interpolateParams;
                    }
                    res = this.missingTranslationHandler.handle(params);
                }
                return typeof res !== "undefined" ? res : key;
            };
        /**
         * Gets the translated value of a key (or an array of keys)
         * @returns the translated key, or an object of translated keys
         */
        /**
         * Gets the translated value of a key (or an array of keys)
         * @param {?} key
         * @param {?=} interpolateParams
         * @return {?} the translated key, or an object of translated keys
         */
        TranslateService.prototype.get = /**
         * Gets the translated value of a key (or an array of keys)
         * @param {?} key
         * @param {?=} interpolateParams
         * @return {?} the translated key, or an object of translated keys
         */
            function (key, interpolateParams) {
                var _this = this;
                if (!isDefined(key) || !key.length) {
                    throw new Error("Parameter \"key\" required");
                }
                // check if we are loading a new translation to use
                if (this.pending) {
                    return rxjs.Observable.create(function (observer) {
                        /** @type {?} */
                        var onComplete = function (res) {
                            observer.next(res);
                            observer.complete();
                        };
                        /** @type {?} */
                        var onError = function (err) {
                            observer.error(err);
                        };
                        _this.loadingTranslations.subscribe(function (res) {
                            res = _this.getParsedResult(res, key, interpolateParams);
                            if (typeof res.subscribe === "function") {
                                res.subscribe(onComplete, onError);
                            }
                            else {
                                onComplete(res);
                            }
                        }, onError);
                    });
                }
                else {
                    /** @type {?} */
                    var res = this.getParsedResult(this.translations[this.currentLang], key, interpolateParams);
                    if (typeof res.subscribe === "function") {
                        return res;
                    }
                    else {
                        return rxjs.of(res);
                    }
                }
            };
        /**
         * Returns a stream of translated values of a key (or an array of keys) which updates
         * whenever the language changes.
         * @returns A stream of the translated key, or an object of translated keys
         */
        /**
         * Returns a stream of translated values of a key (or an array of keys) which updates
         * whenever the language changes.
         * @param {?} key
         * @param {?=} interpolateParams
         * @return {?} A stream of the translated key, or an object of translated keys
         */
        TranslateService.prototype.stream = /**
         * Returns a stream of translated values of a key (or an array of keys) which updates
         * whenever the language changes.
         * @param {?} key
         * @param {?=} interpolateParams
         * @return {?} A stream of the translated key, or an object of translated keys
         */
            function (key, interpolateParams) {
                var _this = this;
                if (!isDefined(key) || !key.length) {
                    throw new Error("Parameter \"key\" required");
                }
                return rxjs.concat(this.get(key, interpolateParams), this.onLangChange.pipe(operators.switchMap(function (event) {
                    /** @type {?} */
                    var res = _this.getParsedResult(event.translations, key, interpolateParams);
                    if (typeof res.subscribe === "function") {
                        return res;
                    }
                    else {
                        return rxjs.of(res);
                    }
                })));
            };
        /**
         * Returns a translation instantly from the internal state of loaded translation.
         * All rules regarding the current language, the preferred language of even fallback languages will be used except any promise handling.
         */
        /**
         * Returns a translation instantly from the internal state of loaded translation.
         * All rules regarding the current language, the preferred language of even fallback languages will be used except any promise handling.
         * @param {?} key
         * @param {?=} interpolateParams
         * @return {?}
         */
        TranslateService.prototype.instant = /**
         * Returns a translation instantly from the internal state of loaded translation.
         * All rules regarding the current language, the preferred language of even fallback languages will be used except any promise handling.
         * @param {?} key
         * @param {?=} interpolateParams
         * @return {?}
         */
            function (key, interpolateParams) {
                if (!isDefined(key) || !key.length) {
                    throw new Error("Parameter \"key\" required");
                }
                /** @type {?} */
                var res = this.getParsedResult(this.translations[this.currentLang], key, interpolateParams);
                if (typeof res.subscribe !== "undefined") {
                    if (key instanceof Array) {
                        /** @type {?} */
                        var obj_1 = {};
                        key.forEach(function (value, index) {
                            obj_1[key[index]] = key[index];
                        });
                        return obj_1;
                    }
                    return key;
                }
                else {
                    return res;
                }
            };
        /**
         * Sets the translated value of a key, after compiling it
         */
        /**
         * Sets the translated value of a key, after compiling it
         * @param {?} key
         * @param {?} value
         * @param {?=} lang
         * @return {?}
         */
        TranslateService.prototype.set = /**
         * Sets the translated value of a key, after compiling it
         * @param {?} key
         * @param {?} value
         * @param {?=} lang
         * @return {?}
         */
            function (key, value, lang) {
                if (lang === void 0) {
                    lang = this.currentLang;
                }
                this.translations[lang][key] = this.compiler.compile(value, lang);
                this.updateLangs();
                this.onTranslationChange.emit({ lang: lang, translations: this.translations[lang] });
            };
        /**
         * Changes the current lang
         */
        /**
         * Changes the current lang
         * @param {?} lang
         * @return {?}
         */
        TranslateService.prototype.changeLang = /**
         * Changes the current lang
         * @param {?} lang
         * @return {?}
         */
            function (lang) {
                this.currentLang = lang;
                this.onLangChange.emit({ lang: lang, translations: this.translations[lang] });
                // if there is no default lang, use the one that we just set
                if (!this.defaultLang) {
                    this.changeDefaultLang(lang);
                }
            };
        /**
         * Changes the default lang
         */
        /**
         * Changes the default lang
         * @param {?} lang
         * @return {?}
         */
        TranslateService.prototype.changeDefaultLang = /**
         * Changes the default lang
         * @param {?} lang
         * @return {?}
         */
            function (lang) {
                this.defaultLang = lang;
                this.onDefaultLangChange.emit({ lang: lang, translations: this.translations[lang] });
            };
        /**
         * Allows to reload the lang file from the file
         */
        /**
         * Allows to reload the lang file from the file
         * @param {?} lang
         * @return {?}
         */
        TranslateService.prototype.reloadLang = /**
         * Allows to reload the lang file from the file
         * @param {?} lang
         * @return {?}
         */
            function (lang) {
                this.resetLang(lang);
                return this.getTranslation(lang);
            };
        /**
         * Deletes inner translation
         */
        /**
         * Deletes inner translation
         * @param {?} lang
         * @return {?}
         */
        TranslateService.prototype.resetLang = /**
         * Deletes inner translation
         * @param {?} lang
         * @return {?}
         */
            function (lang) {
                this._translationRequests[lang] = undefined;
                this.translations[lang] = undefined;
            };
        /**
         * Returns the language code name from the browser, e.g. "de"
         */
        /**
         * Returns the language code name from the browser, e.g. "de"
         * @return {?}
         */
        TranslateService.prototype.getBrowserLang = /**
         * Returns the language code name from the browser, e.g. "de"
         * @return {?}
         */
            function () {
                if (typeof window === 'undefined' || typeof window.navigator === 'undefined') {
                    return undefined;
                }
                /** @type {?} */
                var browserLang = window.navigator.languages ? window.navigator.languages[0] : null;
                browserLang = browserLang || window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage;
                if (browserLang.indexOf('-') !== -1) {
                    browserLang = browserLang.split('-')[0];
                }
                if (browserLang.indexOf('_') !== -1) {
                    browserLang = browserLang.split('_')[0];
                }
                return browserLang;
            };
        /**
         * Returns the culture language code name from the browser, e.g. "de-DE"
         */
        /**
         * Returns the culture language code name from the browser, e.g. "de-DE"
         * @return {?}
         */
        TranslateService.prototype.getBrowserCultureLang = /**
         * Returns the culture language code name from the browser, e.g. "de-DE"
         * @return {?}
         */
            function () {
                if (typeof window === 'undefined' || typeof window.navigator === 'undefined') {
                    return undefined;
                }
                /** @type {?} */
                var browserCultureLang = window.navigator.languages ? window.navigator.languages[0] : null;
                browserCultureLang = browserCultureLang || window.navigator.language || window.navigator.browserLanguage || window.navigator.userLanguage;
                return browserCultureLang;
            };
        /** @nocollapse */
        TranslateService.ctorParameters = function () {
            return [
                { type: TranslateStore },
                { type: TranslateLoader },
                { type: TranslateCompiler },
                { type: TranslateParser },
                { type: MissingTranslationHandler },
                { type: Boolean, decorators: [{ type: core.Inject, args: [USE_DEFAULT_LANG,] }] },
                { type: Boolean, decorators: [{ type: core.Inject, args: [USE_STORE,] }] }
            ];
        };
TranslateService.ɵfac = function TranslateService_Factory(t) { return new (t || TranslateService)(ɵngcc0.ɵɵinject(TranslateStore), ɵngcc0.ɵɵinject(TranslateLoader), ɵngcc0.ɵɵinject(TranslateCompiler), ɵngcc0.ɵɵinject(TranslateParser), ɵngcc0.ɵɵinject(MissingTranslationHandler), ɵngcc0.ɵɵinject(USE_DEFAULT_LANG), ɵngcc0.ɵɵinject(USE_STORE)); };
TranslateService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TranslateService, factory: function (t) { return TranslateService.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TranslateService, [{
        type: core.Injectable
    }], function () { return [{ type: TranslateStore }, { type: TranslateLoader }, { type: TranslateCompiler }, { type: TranslateParser }, { type: MissingTranslationHandler }, { type: Boolean, decorators: [{
                type: core.Inject,
                args: [USE_DEFAULT_LANG]
            }] }, { type: Boolean, decorators: [{
                type: core.Inject,
                args: [USE_STORE]
            }] }]; }, null); })();
        return TranslateService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var TranslateDirective = /** @class */ (function () {
        function TranslateDirective(translateService, element, _ref) {
            var _this = this;
            this.translateService = translateService;
            this.element = element;
            this._ref = _ref;
            // subscribe to onTranslationChange event, in case the translations of the current lang change
            if (!this.onTranslationChangeSub) {
                this.onTranslationChangeSub = this.translateService.onTranslationChange.subscribe(function (event) {
                    if (event.lang === _this.translateService.currentLang) {
                        _this.checkNodes(true, event.translations);
                    }
                });
            }
            // subscribe to onLangChange event, in case the language changes
            if (!this.onLangChangeSub) {
                this.onLangChangeSub = this.translateService.onLangChange.subscribe(function (event) {
                    _this.checkNodes(true, event.translations);
                });
            }
            // subscribe to onDefaultLangChange event, in case the default language changes
            if (!this.onDefaultLangChangeSub) {
                this.onDefaultLangChangeSub = this.translateService.onDefaultLangChange.subscribe(function (event) {
                    _this.checkNodes(true);
                });
            }
        }
        Object.defineProperty(TranslateDirective.prototype, "translate", {
            set: /**
             * @param {?} key
             * @return {?}
             */ function (key) {
                if (key) {
                    this.key = key;
                    this.checkNodes();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TranslateDirective.prototype, "translateParams", {
            set: /**
             * @param {?} params
             * @return {?}
             */ function (params) {
                if (!equals(this.currentParams, params)) {
                    this.currentParams = params;
                    this.checkNodes(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TranslateDirective.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                this.checkNodes();
            };
        /**
         * @param {?=} forceUpdate
         * @param {?=} translations
         * @return {?}
         */
        TranslateDirective.prototype.checkNodes = /**
         * @param {?=} forceUpdate
         * @param {?=} translations
         * @return {?}
         */
            function (forceUpdate, translations) {
                if (forceUpdate === void 0) {
                    forceUpdate = false;
                }
                /** @type {?} */
                var nodes = this.element.nativeElement.childNodes;
                // if the element is empty
                if (!nodes.length) {
                    // we add the key as content
                    this.setContent(this.element.nativeElement, this.key);
                    nodes = this.element.nativeElement.childNodes;
                }
                for (var i = 0; i < nodes.length; ++i) {
                    /** @type {?} */
                    var node = nodes[i];
                    if (node.nodeType === 3) { // node type 3 is a text node
                        // node type 3 is a text node
                        /** @type {?} */
                        var key = void 0;
                        if (this.key) {
                            key = this.key;
                            if (forceUpdate) {
                                node.lastKey = null;
                            }
                        }
                        else {
                            /** @type {?} */
                            var content = this.getContent(node);
                            /** @type {?} */
                            var trimmedContent = content.trim();
                            if (trimmedContent.length) {
                                // we want to use the content as a key, not the translation value
                                if (content !== node.currentValue) {
                                    key = trimmedContent;
                                    // the content was changed from the user, we'll use it as a reference if needed
                                    node.originalContent = this.getContent(node);
                                }
                                else if (node.originalContent && forceUpdate) { // the content seems ok, but the lang has changed
                                    node.lastKey = null;
                                    // the current content is the translation, not the key, use the last real content as key
                                    key = node.originalContent.trim();
                                }
                            }
                        }
                        this.updateValue(key, node, translations);
                    }
                }
            };
        /**
         * @param {?} key
         * @param {?} node
         * @param {?} translations
         * @return {?}
         */
        TranslateDirective.prototype.updateValue = /**
         * @param {?} key
         * @param {?} node
         * @param {?} translations
         * @return {?}
         */
            function (key, node, translations) {
                var _this = this;
                if (key) {
                    if (node.lastKey === key && this.lastParams === this.currentParams) {
                        return;
                    }
                    this.lastParams = this.currentParams;
                    /** @type {?} */
                    var onTranslation = function (res) {
                        if (res !== key) {
                            node.lastKey = key;
                        }
                        if (!node.originalContent) {
                            node.originalContent = _this.getContent(node);
                        }
                        node.currentValue = isDefined(res) ? res : (node.originalContent || key);
                        // we replace in the original content to preserve spaces that we might have trimmed
                        _this.setContent(node, _this.key ? node.currentValue : node.originalContent.replace(key, node.currentValue));
                        _this._ref.markForCheck();
                    };
                    if (isDefined(translations)) {
                        /** @type {?} */
                        var res = this.translateService.getParsedResult(translations, key, this.currentParams);
                        if (typeof res.subscribe === "function") {
                            res.subscribe(onTranslation);
                        }
                        else {
                            onTranslation(res);
                        }
                    }
                    else {
                        this.translateService.get(key, this.currentParams).subscribe(onTranslation);
                    }
                }
            };
        /**
         * @param {?} node
         * @return {?}
         */
        TranslateDirective.prototype.getContent = /**
         * @param {?} node
         * @return {?}
         */
            function (node) {
                return isDefined(node.textContent) ? node.textContent : node.data;
            };
        /**
         * @param {?} node
         * @param {?} content
         * @return {?}
         */
        TranslateDirective.prototype.setContent = /**
         * @param {?} node
         * @param {?} content
         * @return {?}
         */
            function (node, content) {
                if (isDefined(node.textContent)) {
                    node.textContent = content;
                }
                else {
                    node.data = content;
                }
            };
        /**
         * @return {?}
         */
        TranslateDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.onLangChangeSub) {
                    this.onLangChangeSub.unsubscribe();
                }
                if (this.onDefaultLangChangeSub) {
                    this.onDefaultLangChangeSub.unsubscribe();
                }
                if (this.onTranslationChangeSub) {
                    this.onTranslationChangeSub.unsubscribe();
                }
            };
        /** @nocollapse */
        TranslateDirective.ctorParameters = function () {
            return [
                { type: TranslateService },
                { type: core.ElementRef },
                { type: core.ChangeDetectorRef }
            ];
        };
        TranslateDirective.propDecorators = {
            translate: [{ type: core.Input }],
            translateParams: [{ type: core.Input }]
        };
TranslateDirective.ɵfac = function TranslateDirective_Factory(t) { return new (t || TranslateDirective)(ɵngcc0.ɵɵdirectiveInject(TranslateService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
TranslateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TranslateDirective, selectors: [["", "translate", ""], ["", "ngx-translate", ""]], inputs: { translate: "translate", translateParams: "translateParams" } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TranslateDirective, [{
        type: core.Directive,
        args: [{
                selector: '[translate],[ngx-translate]'
            }]
    }], function () { return [{ type: TranslateService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { translate: [{
            type: core.Input
        }], translateParams: [{
            type: core.Input
        }] }); })();
        return TranslateDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var TranslatePipe = /** @class */ (function () {
        function TranslatePipe(translate, _ref) {
            this.translate = translate;
            this._ref = _ref;
            this.value = '';
        }
        /**
         * @param {?} key
         * @param {?=} interpolateParams
         * @param {?=} translations
         * @return {?}
         */
        TranslatePipe.prototype.updateValue = /**
         * @param {?} key
         * @param {?=} interpolateParams
         * @param {?=} translations
         * @return {?}
         */
            function (key, interpolateParams, translations) {
                var _this = this;
                /** @type {?} */
                var onTranslation = function (res) {
                    _this.value = res !== undefined ? res : key;
                    _this.lastKey = key;
                    _this._ref.markForCheck();
                };
                if (translations) {
                    /** @type {?} */
                    var res = this.translate.getParsedResult(translations, key, interpolateParams);
                    if (typeof res.subscribe === 'function') {
                        res.subscribe(onTranslation);
                    }
                    else {
                        onTranslation(res);
                    }
                }
                this.translate.get(key, interpolateParams).subscribe(onTranslation);
            };
        /**
         * @param {?} query
         * @param {...?} args
         * @return {?}
         */
        TranslatePipe.prototype.transform = /**
         * @param {?} query
         * @param {...?} args
         * @return {?}
         */
            function (query) {
                var _this = this;
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (!query || query.length === 0) {
                    return query;
                }
                // if we ask another time for the same key, return the last value
                if (equals(query, this.lastKey) && equals(args, this.lastParams)) {
                    return this.value;
                }
                /** @type {?} */
                var interpolateParams;
                if (isDefined(args[0]) && args.length) {
                    if (typeof args[0] === 'string' && args[0].length) {
                        // we accept objects written in the template such as {n:1}, {'n':1}, {n:'v'}
                        // which is why we might need to change it to real JSON objects such as {"n":1} or {"n":"v"}
                        /** @type {?} */
                        var validArgs = args[0]
                            .replace(/(\')?([a-zA-Z0-9_]+)(\')?(\s)?:/g, '"$2":')
                            .replace(/:(\s)?(\')(.*?)(\')/g, ':"$3"');
                        try {
                            interpolateParams = JSON.parse(validArgs);
                        }
                        catch (e) {
                            throw new SyntaxError("Wrong parameter in TranslatePipe. Expected a valid Object, received: " + args[0]);
                        }
                    }
                    else if (typeof args[0] === 'object' && !Array.isArray(args[0])) {
                        interpolateParams = args[0];
                    }
                }
                // store the query, in case it changes
                this.lastKey = query;
                // store the params, in case they change
                this.lastParams = args;
                // set the value
                this.updateValue(query, interpolateParams);
                // if there is a subscription to onLangChange, clean it
                this._dispose();
                // subscribe to onTranslationChange event, in case the translations change
                if (!this.onTranslationChange) {
                    this.onTranslationChange = this.translate.onTranslationChange.subscribe(function (event) {
                        if (_this.lastKey && event.lang === _this.translate.currentLang) {
                            _this.lastKey = null;
                            _this.updateValue(query, interpolateParams, event.translations);
                        }
                    });
                }
                // subscribe to onLangChange event, in case the language changes
                if (!this.onLangChange) {
                    this.onLangChange = this.translate.onLangChange.subscribe(function (event) {
                        if (_this.lastKey) {
                            _this.lastKey = null; // we want to make sure it doesn't return the same value until it's been updated
                            _this.updateValue(query, interpolateParams, event.translations);
                        }
                    });
                }
                // subscribe to onDefaultLangChange event, in case the default language changes
                if (!this.onDefaultLangChange) {
                    this.onDefaultLangChange = this.translate.onDefaultLangChange.subscribe(function () {
                        if (_this.lastKey) {
                            _this.lastKey = null; // we want to make sure it doesn't return the same value until it's been updated
                            _this.updateValue(query, interpolateParams);
                        }
                    });
                }
                return this.value;
            };
        /**
         * Clean any existing subscription to change events
         */
        /**
         * Clean any existing subscription to change events
         * @return {?}
         */
        TranslatePipe.prototype._dispose = /**
         * Clean any existing subscription to change events
         * @return {?}
         */
            function () {
                if (typeof this.onTranslationChange !== 'undefined') {
                    this.onTranslationChange.unsubscribe();
                    this.onTranslationChange = undefined;
                }
                if (typeof this.onLangChange !== 'undefined') {
                    this.onLangChange.unsubscribe();
                    this.onLangChange = undefined;
                }
                if (typeof this.onDefaultLangChange !== 'undefined') {
                    this.onDefaultLangChange.unsubscribe();
                    this.onDefaultLangChange = undefined;
                }
            };
        /**
         * @return {?}
         */
        TranslatePipe.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._dispose();
            };
        /** @nocollapse */
        TranslatePipe.ctorParameters = function () {
            return [
                { type: TranslateService },
                { type: core.ChangeDetectorRef }
            ];
        };
TranslatePipe.ɵfac = function TranslatePipe_Factory(t) { return new (t || TranslatePipe)(ɵngcc0.ɵɵdirectiveInject(TranslateService), ɵngcc0.ɵɵinjectPipeChangeDetectorRef()); };
TranslatePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "translate", type: TranslatePipe, pure: false });
TranslatePipe.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TranslatePipe, factory: function (t) { return TranslatePipe.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TranslatePipe, [{
        type: core.Injectable
    }, {
        type: core.Pipe,
        args: [{
                name: 'translate',
                pure: false // required to update the value when the promise is resolved
            }]
    }], function () { return [{ type: TranslateService }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
        return TranslatePipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var TranslateModule = /** @class */ (function () {
        function TranslateModule() {
        }
        /**
         * Use this method in your root module to provide the TranslateService
         */
        /**
         * Use this method in your root module to provide the TranslateService
         * @param {?=} config
         * @return {?}
         */
        TranslateModule.forRoot = /**
         * Use this method in your root module to provide the TranslateService
         * @param {?=} config
         * @return {?}
         */
            function (config) {
                if (config === void 0) {
                    config = {};
                }
                return {
                    ngModule: TranslateModule,
                    providers: [
                        config.loader || { provide: TranslateLoader, useClass: TranslateFakeLoader },
                        config.compiler || { provide: TranslateCompiler, useClass: TranslateFakeCompiler },
                        config.parser || { provide: TranslateParser, useClass: TranslateDefaultParser },
                        config.missingTranslationHandler || { provide: MissingTranslationHandler, useClass: FakeMissingTranslationHandler },
                        TranslateStore,
                        { provide: USE_STORE, useValue: config.isolate },
                        { provide: USE_DEFAULT_LANG, useValue: config.useDefaultLang },
                        TranslateService
                    ]
                };
            };
        /**
         * Use this method in your other (non root) modules to import the directive/pipe
         */
        /**
         * Use this method in your other (non root) modules to import the directive/pipe
         * @param {?=} config
         * @return {?}
         */
        TranslateModule.forChild = /**
         * Use this method in your other (non root) modules to import the directive/pipe
         * @param {?=} config
         * @return {?}
         */
            function (config) {
                if (config === void 0) {
                    config = {};
                }
                return {
                    ngModule: TranslateModule,
                    providers: [
                        config.loader || { provide: TranslateLoader, useClass: TranslateFakeLoader },
                        config.compiler || { provide: TranslateCompiler, useClass: TranslateFakeCompiler },
                        config.parser || { provide: TranslateParser, useClass: TranslateDefaultParser },
                        config.missingTranslationHandler || { provide: MissingTranslationHandler, useClass: FakeMissingTranslationHandler },
                        { provide: USE_STORE, useValue: config.isolate },
                        { provide: USE_DEFAULT_LANG, useValue: config.useDefaultLang },
                        TranslateService
                    ]
                };
            };
TranslateModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TranslateModule });
TranslateModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TranslateModule_Factory(t) { return new (t || TranslateModule)(); } });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TranslateModule, { declarations: [TranslatePipe,
        TranslateDirective], exports: [TranslatePipe,
        TranslateDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TranslateModule, [{
        type: core.NgModule,
        args: [{
                declarations: [
                    TranslatePipe,
                    TranslateDirective
                ],
                exports: [
                    TranslatePipe,
                    TranslateDirective
                ]
            }]
    }], function () { return []; }, null); })();
        return TranslateModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.TranslateModule = TranslateModule;
    exports.TranslateLoader = TranslateLoader;
    exports.TranslateFakeLoader = TranslateFakeLoader;
    exports.USE_STORE = USE_STORE;
    exports.USE_DEFAULT_LANG = USE_DEFAULT_LANG;
    exports.TranslateService = TranslateService;
    exports.MissingTranslationHandler = MissingTranslationHandler;
    exports.FakeMissingTranslationHandler = FakeMissingTranslationHandler;
    exports.TranslateParser = TranslateParser;
    exports.TranslateDefaultParser = TranslateDefaultParser;
    exports.TranslateCompiler = TranslateCompiler;
    exports.TranslateFakeCompiler = TranslateFakeCompiler;
    exports.TranslateDirective = TranslateDirective;
    exports.TranslatePipe = TranslatePipe;
    exports.TranslateStore = TranslateStore;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkQ6L2Jhay9iZXJhdHVuZy9hbmd1bGFyMi93b3Jrc2hvcHNfYWR2YW5jZWQvYWR2YW5jZWQtbngtd29ya3NwYWNlL25vZGVfbW9kdWxlcy9Abmd4LXRyYW5zbGF0ZS9jb3JlL2J1bmRsZXMvbmd4LXRyYW5zbGF0ZS1jb3JlLnVtZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtvR0FDMkU7Z0dBQ0s7NEJBQ25FOzBCQUNNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Y0EyRUw7Ozs7OzswQkFHSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztjQWtDSTs7Ozs7Z0RBR0o7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztjQW1ESTs7Ozs7OzBCQUdKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2NBK05JOzs7Ozs7MEJBR0o7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2NBdTBCSSxBQUdKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQ0FZQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztjQTROSSxBQUtKOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBWUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Y0FnS0ksQUFPSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4R0FPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Y0F1RUk7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFZSiIsImZpbGUiOiJuZ3gtdHJhbnNsYXRlLWNvcmUudW1kLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0Bhbmd1bGFyL2NvcmUnKSwgcmVxdWlyZSgncnhqcycpLCByZXF1aXJlKCdyeGpzL29wZXJhdG9ycycpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCdAbmd4LXRyYW5zbGF0ZS9jb3JlJywgWydleHBvcnRzJywgJ0Bhbmd1bGFyL2NvcmUnLCAncnhqcycsICdyeGpzL29wZXJhdG9ycyddLCBmYWN0b3J5KSA6XG4gICAgKGZhY3RvcnkoKGdsb2JhbFsnbmd4LXRyYW5zbGF0ZSddID0gZ2xvYmFsWyduZ3gtdHJhbnNsYXRlJ10gfHwge30sIGdsb2JhbFsnbmd4LXRyYW5zbGF0ZSddLmNvcmUgPSB7fSksZ2xvYmFsLm5nLmNvcmUsZ2xvYmFsLnJ4anMsZ2xvYmFsLnJ4anMub3BlcmF0b3JzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxjb3JlLHJ4anMsb3BlcmF0b3JzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxuICAgIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXG4gICAgTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICAgIFRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAgICBLSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXG4gICAgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcbiAgICBNRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxuXG4gICAgU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXG4gICAgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG4gICAgLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYilcbiAgICAgICAgICAgICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSlcbiAgICAgICAgICAgICAgICAgICAgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX192YWx1ZXMobykge1xuICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xuICAgICAgICBpZiAobSlcbiAgICAgICAgICAgIHJldHVybiBtLmNhbGwobyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gICAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICovIFRyYW5zbGF0ZUxvYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVHJhbnNsYXRlTG9hZGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUcmFuc2xhdGVMb2FkZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGxvYWRlciBpcyBqdXN0IGEgcGxhY2Vob2xkZXIgdGhhdCBkb2VzIG5vdGhpbmcsIGluIGNhc2UgeW91IGRvbid0IG5lZWQgYSBsb2FkZXIgYXQgYWxsXG4gICAgICovXG4gICAgdmFyIFRyYW5zbGF0ZUZha2VMb2FkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhUcmFuc2xhdGVGYWtlTG9hZGVyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBUcmFuc2xhdGVGYWtlTG9hZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGxhbmdcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRyYW5zbGF0ZUZha2VMb2FkZXIucHJvdG90eXBlLmdldFRyYW5zbGF0aW9uID0gLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbGFuZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChsYW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMub2Yoe30pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgVHJhbnNsYXRlRmFrZUxvYWRlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBjb3JlLkluamVjdGFibGUgfVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gVHJhbnNsYXRlRmFrZUxvYWRlcjtcbiAgICB9KFRyYW5zbGF0ZUxvYWRlcikpO1xuXG4gICAgLyoqXG4gICAgICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gICAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICovIE1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGhhbmRsZXIgaXMganVzdCBhIHBsYWNlaG9sZGVyIHRoYXQgZG9lcyBub3RoaW5nLCBpbiBjYXNlIHlvdSBkb24ndCBuZWVkIGEgbWlzc2luZyB0cmFuc2xhdGlvbiBoYW5kbGVyIGF0IGFsbFxuICAgICAqL1xuICAgIHZhciBGYWtlTWlzc2luZ1RyYW5zbGF0aW9uSGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRmFrZU1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyYW1zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBGYWtlTWlzc2luZ1RyYW5zbGF0aW9uSGFuZGxlci5wcm90b3R5cGUuaGFuZGxlID0gLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyYW1zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbXMua2V5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgRmFrZU1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogY29yZS5JbmplY3RhYmxlIH1cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIEZha2VNaXNzaW5nVHJhbnNsYXRpb25IYW5kbGVyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAgICAgKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhciAvKipcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi8gVHJhbnNsYXRlQ29tcGlsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRyYW5zbGF0ZUNvbXBpbGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUcmFuc2xhdGVDb21waWxlcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFRoaXMgY29tcGlsZXIgaXMganVzdCBhIHBsYWNlaG9sZGVyIHRoYXQgZG9lcyBub3RoaW5nLCBpbiBjYXNlIHlvdSBkb24ndCBuZWVkIGEgY29tcGlsZXIgYXQgYWxsXG4gICAgICovXG4gICAgdmFyIFRyYW5zbGF0ZUZha2VDb21waWxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKFRyYW5zbGF0ZUZha2VDb21waWxlciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVHJhbnNsYXRlRmFrZUNvbXBpbGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7P30gbGFuZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVHJhbnNsYXRlRmFrZUNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlID0gLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHs/fSBsYW5nXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlLCBsYW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdHJhbnNsYXRpb25zXG4gICAgICAgICAqIEBwYXJhbSB7P30gbGFuZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVHJhbnNsYXRlRmFrZUNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlVHJhbnNsYXRpb25zID0gLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdHJhbnNsYXRpb25zXG4gICAgICAgICAqIEBwYXJhbSB7P30gbGFuZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uICh0cmFuc2xhdGlvbnMsIGxhbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRpb25zO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgVHJhbnNsYXRlRmFrZUNvbXBpbGVyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IGNvcmUuSW5qZWN0YWJsZSB9XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBUcmFuc2xhdGVGYWtlQ29tcGlsZXI7XG4gICAgfShUcmFuc2xhdGVDb21waWxlcikpO1xuXG4gICAgLyoqXG4gICAgICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gICAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAgICAgKi9cbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdHdvIG9iamVjdHMgb3IgdHdvIHZhbHVlcyBhcmUgZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqIFR3byBvYmplY3RzIG9yIHZhbHVlcyBhcmUgY29uc2lkZXJlZCBlcXVpdmFsZW50IGlmIGF0IGxlYXN0IG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gICAgICpcbiAgICAgKiAqIEJvdGggb2JqZWN0cyBvciB2YWx1ZXMgcGFzcyBgPT09YCBjb21wYXJpc29uLlxuICAgICAqICogQm90aCBvYmplY3RzIG9yIHZhbHVlcyBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmQgYWxsIG9mIHRoZWlyIHByb3BlcnRpZXMgYXJlIGVxdWFsIGJ5XG4gICAgICogICBjb21wYXJpbmcgdGhlbSB3aXRoIGBlcXVhbHNgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/fSBvMSBPYmplY3Qgb3IgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0gez99IG8yIE9iamVjdCBvciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm4gez99IHRydWUgaWYgYXJndW1lbnRzIGFyZSBlcXVhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHMobzEsIG8yKSB7XG4gICAgICAgIGlmIChvMSA9PT0gbzIpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG8xID09PSBudWxsIHx8IG8yID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobzEgIT09IG8xICYmIG8yICE9PSBvMilcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBOYU4gPT09IE5hTlxuICAgICAgICAvLyBOYU4gPT09IE5hTlxuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciB0MSA9IHR5cGVvZiBvMTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgdDIgPSB0eXBlb2YgbzI7XG4gICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgdmFyIGxlbmd0aDtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBrZXlTZXQ7XG4gICAgICAgIGlmICh0MSA9PSB0MiAmJiB0MSA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobzEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG8yKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICgobGVuZ3RoID0gbzEubGVuZ3RoKSA9PSBvMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgPSAwOyBrZXkgPCBsZW5ndGg7IGtleSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVxdWFscyhvMVtrZXldLCBvMltrZXldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobzIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2V5U2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBvMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVxdWFscyhvMVtrZXldLCBvMltrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGtleVNldFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gbzIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIGtleVNldCkgJiYgdHlwZW9mIG8yW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKiB0c2xpbnQ6ZW5hYmxlICovXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZVxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNEZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlICE9PSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGl0ZW1cbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIChpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpdGVtKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICogQHBhcmFtIHs/fSBzb3VyY2VcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlRGVlcCh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBvdXRwdXQgPSBPYmplY3QuYXNzaWduKHt9LCB0YXJnZXQpO1xuICAgICAgICBpZiAoaXNPYmplY3QodGFyZ2V0KSAmJiBpc09iamVjdChzb3VyY2UpKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvdXRwdXQsIChfYSA9IHt9LCBfYVtrZXldID0gc291cmNlW2tleV0sIF9hKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IG1lcmdlRGVlcCh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKG91dHB1dCwgKF9iID0ge30sIF9iW2tleV0gPSBzb3VyY2Vba2V5XSwgX2IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmaWxlb3ZlcnZpZXcgYWRkZWQgYnkgdHNpY2tsZVxuICAgICAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlcyxleHRyYVJlcXVpcmUsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgdmFyIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqLyBUcmFuc2xhdGVQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRyYW5zbGF0ZVBhcnNlcigpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHJhbnNsYXRlUGFyc2VyO1xuICAgIH0oKSk7XG4gICAgdmFyIFRyYW5zbGF0ZURlZmF1bHRQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhUcmFuc2xhdGVEZWZhdWx0UGFyc2VyLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBUcmFuc2xhdGVEZWZhdWx0UGFyc2VyKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy50ZW1wbGF0ZU1hdGNoZXIgPSAve3tcXHM/KFtee31cXHNdKilcXHM/fX0vZztcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHBhcmFtc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVHJhbnNsYXRlRGVmYXVsdFBhcnNlci5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBleHByXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHBhcmFtc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChleHByLCBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4cHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuaW50ZXJwb2xhdGVTdHJpbmcoZXhwciwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGV4cHIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5pbnRlcnBvbGF0ZUZ1bmN0aW9uKGV4cHIsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHNob3VsZCBub3QgaGFwcGVuLCBidXQgYW4gdW5yZWxhdGVkIFRyYW5zbGF0ZVNlcnZpY2UgdGVzdCBkZXBlbmRzIG9uIGl0XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICggLyoqIEB0eXBlIHs/fSAqLyhleHByKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRyYW5zbGF0ZURlZmF1bHRQYXJzZXIucHJvdG90eXBlLmdldFZhbHVlID0gLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gdGFyZ2V0XG4gICAgICAgICAqIEBwYXJhbSB7P30ga2V5XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgIHZhciBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAga2V5ID0gJyc7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBrZXkgKz0ga2V5cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWZpbmVkKHRhcmdldCkgJiYgaXNEZWZpbmVkKHRhcmdldFtrZXldKSAmJiAodHlwZW9mIHRhcmdldFtrZXldID09PSAnb2JqZWN0JyB8fCAha2V5cy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ICs9ICcuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKGtleXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHBhcmFtIHs/PX0gcGFyYW1zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUcmFuc2xhdGVEZWZhdWx0UGFyc2VyLnByb3RvdHlwZS5pbnRlcnBvbGF0ZUZ1bmN0aW9uID0gLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gZm5cbiAgICAgICAgICogQHBhcmFtIHs/PX0gcGFyYW1zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKGZuLCBwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4ocGFyYW1zKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgICAgICogQHBhcmFtIHs/PX0gcGFyYW1zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUcmFuc2xhdGVEZWZhdWx0UGFyc2VyLnByb3RvdHlwZS5pbnRlcnBvbGF0ZVN0cmluZyA9IC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGV4cHJcbiAgICAgICAgICogQHBhcmFtIHs/PX0gcGFyYW1zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKGV4cHIsIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBleHByLnJlcGxhY2UodGhpcy50ZW1wbGF0ZU1hdGNoZXIsIGZ1bmN0aW9uIChzdWJzdHJpbmcsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IF90aGlzLmdldFZhbHVlKHBhcmFtcywgYik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0RlZmluZWQocikgPyByIDogc3Vic3RyaW5nO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgVHJhbnNsYXRlRGVmYXVsdFBhcnNlci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBjb3JlLkluamVjdGFibGUgfVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gVHJhbnNsYXRlRGVmYXVsdFBhcnNlcjtcbiAgICB9KFRyYW5zbGF0ZVBhcnNlcikpO1xuXG4gICAgLyoqXG4gICAgICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gICAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAgICAgKi9cbiAgICB2YXIgVHJhbnNsYXRlU3RvcmUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRyYW5zbGF0ZVN0b3JlKCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgbGFuZyBjdXJyZW50bHkgdXNlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRMYW5nID0gdGhpcy5kZWZhdWx0TGFuZztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogYSBsaXN0IG9mIHRyYW5zbGF0aW9ucyBwZXIgbGFuZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnRyYW5zbGF0aW9ucyA9IHt9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBhbiBhcnJheSBvZiBsYW5nc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmxhbmdzID0gW107XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFuIEV2ZW50RW1pdHRlciB0byBsaXN0ZW4gdG8gdHJhbnNsYXRpb24gY2hhbmdlIGV2ZW50c1xuICAgICAgICAgICAgICogb25UcmFuc2xhdGlvbkNoYW5nZS5zdWJzY3JpYmUoKHBhcmFtczogVHJhbnNsYXRpb25DaGFuZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICogICAgIC8vIGRvIHNvbWV0aGluZ1xuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMub25UcmFuc2xhdGlvbkNoYW5nZSA9IG5ldyBjb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbiBFdmVudEVtaXR0ZXIgdG8gbGlzdGVuIHRvIGxhbmcgY2hhbmdlIGV2ZW50c1xuICAgICAgICAgICAgICogb25MYW5nQ2hhbmdlLnN1YnNjcmliZSgocGFyYW1zOiBMYW5nQ2hhbmdlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAqICAgICAvLyBkbyBzb21ldGhpbmdcbiAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm9uTGFuZ0NoYW5nZSA9IG5ldyBjb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbiBFdmVudEVtaXR0ZXIgdG8gbGlzdGVuIHRvIGRlZmF1bHQgbGFuZyBjaGFuZ2UgZXZlbnRzXG4gICAgICAgICAgICAgKiBvbkRlZmF1bHRMYW5nQ2hhbmdlLnN1YnNjcmliZSgocGFyYW1zOiBEZWZhdWx0TGFuZ0NoYW5nZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgKiAgICAgLy8gZG8gc29tZXRoaW5nXG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5vbkRlZmF1bHRMYW5nQ2hhbmdlID0gbmV3IGNvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRyYW5zbGF0ZVN0b3JlO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAgICAgKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICAgICAqL1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICB2YXIgVVNFX1NUT1JFID0gbmV3IGNvcmUuSW5qZWN0aW9uVG9rZW4oJ1VTRV9TVE9SRScpO1xuICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICB2YXIgVVNFX0RFRkFVTFRfTEFORyA9IG5ldyBjb3JlLkluamVjdGlvblRva2VuKCdVU0VfREVGQVVMVF9MQU5HJyk7XG4gICAgdmFyIFRyYW5zbGF0ZVNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc3RvcmUgYW4gaW5zdGFuY2Ugb2YgdGhlIHN0b3JlICh0aGF0IGlzIHN1cHBvc2VkIHRvIGJlIHVuaXF1ZSlcbiAgICAgICAgICogQHBhcmFtIGN1cnJlbnRMb2FkZXIgQW4gaW5zdGFuY2Ugb2YgdGhlIGxvYWRlciBjdXJyZW50bHkgdXNlZFxuICAgICAgICAgKiBAcGFyYW0gY29tcGlsZXIgQW4gaW5zdGFuY2Ugb2YgdGhlIGNvbXBpbGVyIGN1cnJlbnRseSB1c2VkXG4gICAgICAgICAqIEBwYXJhbSBwYXJzZXIgQW4gaW5zdGFuY2Ugb2YgdGhlIHBhcnNlciBjdXJyZW50bHkgdXNlZFxuICAgICAgICAgKiBAcGFyYW0gbWlzc2luZ1RyYW5zbGF0aW9uSGFuZGxlciBBIGhhbmRsZXIgZm9yIG1pc3NpbmcgdHJhbnNsYXRpb25zLlxuICAgICAgICAgKiBAcGFyYW0gaXNvbGF0ZSB3aGV0aGVyIHRoaXMgc2VydmljZSBzaG91bGQgdXNlIHRoZSBzdG9yZSBvciBub3RcbiAgICAgICAgICogQHBhcmFtIHVzZURlZmF1bHRMYW5nIHdoZXRoZXIgd2Ugc2hvdWxkIHVzZSBkZWZhdWx0IGxhbmd1YWdlIHRyYW5zbGF0aW9uIHdoZW4gY3VycmVudCBsYW5ndWFnZSB0cmFuc2xhdGlvbiBpcyBtaXNzaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVHJhbnNsYXRlU2VydmljZShzdG9yZSwgY3VycmVudExvYWRlciwgY29tcGlsZXIsIHBhcnNlciwgbWlzc2luZ1RyYW5zbGF0aW9uSGFuZGxlciwgdXNlRGVmYXVsdExhbmcsIGlzb2xhdGUpIHtcbiAgICAgICAgICAgIGlmICh1c2VEZWZhdWx0TGFuZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgdXNlRGVmYXVsdExhbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzb2xhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGlzb2xhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudExvYWRlciA9IGN1cnJlbnRMb2FkZXI7XG4gICAgICAgICAgICB0aGlzLmNvbXBpbGVyID0gY29tcGlsZXI7XG4gICAgICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgICAgIHRoaXMubWlzc2luZ1RyYW5zbGF0aW9uSGFuZGxlciA9IG1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXI7XG4gICAgICAgICAgICB0aGlzLnVzZURlZmF1bHRMYW5nID0gdXNlRGVmYXVsdExhbmc7XG4gICAgICAgICAgICB0aGlzLmlzb2xhdGUgPSBpc29sYXRlO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9vblRyYW5zbGF0aW9uQ2hhbmdlID0gbmV3IGNvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9vbkxhbmdDaGFuZ2UgPSBuZXcgY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX29uRGVmYXVsdExhbmdDaGFuZ2UgPSBuZXcgY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2xhbmdzID0gW107XG4gICAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uUmVxdWVzdHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNsYXRlU2VydmljZS5wcm90b3R5cGUsIFwib25UcmFuc2xhdGlvbkNoYW5nZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFuIEV2ZW50RW1pdHRlciB0byBsaXN0ZW4gdG8gdHJhbnNsYXRpb24gY2hhbmdlIGV2ZW50c1xuICAgICAgICAgICAgICogb25UcmFuc2xhdGlvbkNoYW5nZS5zdWJzY3JpYmUoKHBhcmFtczogVHJhbnNsYXRpb25DaGFuZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgKiAgICAgLy8gZG8gc29tZXRoaW5nXG4gICAgICAgICAgICAgICAqIH0pO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgICAgICogQW4gRXZlbnRFbWl0dGVyIHRvIGxpc3RlbiB0byB0cmFuc2xhdGlvbiBjaGFuZ2UgZXZlbnRzXG4gICAgICAgICAgICAgKiBvblRyYW5zbGF0aW9uQ2hhbmdlLnN1YnNjcmliZSgocGFyYW1zOiBUcmFuc2xhdGlvbkNoYW5nZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgKiAgICAgLy8gZG8gc29tZXRoaW5nXG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzb2xhdGUgPyB0aGlzLl9vblRyYW5zbGF0aW9uQ2hhbmdlIDogdGhpcy5zdG9yZS5vblRyYW5zbGF0aW9uQ2hhbmdlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2xhdGVTZXJ2aWNlLnByb3RvdHlwZSwgXCJvbkxhbmdDaGFuZ2VcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbiBFdmVudEVtaXR0ZXIgdG8gbGlzdGVuIHRvIGxhbmcgY2hhbmdlIGV2ZW50c1xuICAgICAgICAgICAgICogb25MYW5nQ2hhbmdlLnN1YnNjcmliZSgocGFyYW1zOiBMYW5nQ2hhbmdlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICogICAgIC8vIGRvIHNvbWV0aGluZ1xuICAgICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICAgICAqIEFuIEV2ZW50RW1pdHRlciB0byBsaXN0ZW4gdG8gbGFuZyBjaGFuZ2UgZXZlbnRzXG4gICAgICAgICAgICAgKiBvbkxhbmdDaGFuZ2Uuc3Vic2NyaWJlKChwYXJhbXM6IExhbmdDaGFuZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICogICAgIC8vIGRvIHNvbWV0aGluZ1xuICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc29sYXRlID8gdGhpcy5fb25MYW5nQ2hhbmdlIDogdGhpcy5zdG9yZS5vbkxhbmdDaGFuZ2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zbGF0ZVNlcnZpY2UucHJvdG90eXBlLCBcIm9uRGVmYXVsdExhbmdDaGFuZ2VcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbiBFdmVudEVtaXR0ZXIgdG8gbGlzdGVuIHRvIGRlZmF1bHQgbGFuZyBjaGFuZ2UgZXZlbnRzXG4gICAgICAgICAgICAgKiBvbkRlZmF1bHRMYW5nQ2hhbmdlLnN1YnNjcmliZSgocGFyYW1zOiBEZWZhdWx0TGFuZ0NoYW5nZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAqICAgICAvLyBkbyBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICogfSk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogLyoqXG4gICAgICAgICAgICAgKiBBbiBFdmVudEVtaXR0ZXIgdG8gbGlzdGVuIHRvIGRlZmF1bHQgbGFuZyBjaGFuZ2UgZXZlbnRzXG4gICAgICAgICAgICAgKiBvbkRlZmF1bHRMYW5nQ2hhbmdlLnN1YnNjcmliZSgocGFyYW1zOiBEZWZhdWx0TGFuZ0NoYW5nZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgKiAgICAgLy8gZG8gc29tZXRoaW5nXG4gICAgICAgICAgICAgKiB9KTtcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzb2xhdGUgPyB0aGlzLl9vbkRlZmF1bHRMYW5nQ2hhbmdlIDogdGhpcy5zdG9yZS5vbkRlZmF1bHRMYW5nQ2hhbmdlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2xhdGVTZXJ2aWNlLnByb3RvdHlwZSwgXCJkZWZhdWx0TGFuZ1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBkZWZhdWx0IGxhbmcgdG8gZmFsbGJhY2sgd2hlbiB0cmFuc2xhdGlvbnMgYXJlIG1pc3Npbmcgb24gdGhlIGN1cnJlbnQgbGFuZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IC8qKlxuICAgICAgICAgICAgICogVGhlIGRlZmF1bHQgbGFuZyB0byBmYWxsYmFjayB3aGVuIHRyYW5zbGF0aW9ucyBhcmUgbWlzc2luZyBvbiB0aGUgY3VycmVudCBsYW5nXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc29sYXRlID8gdGhpcy5fZGVmYXVsdExhbmcgOiB0aGlzLnN0b3JlLmRlZmF1bHRMYW5nO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGRlZmF1bHRMYW5nXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovIGZ1bmN0aW9uIChkZWZhdWx0TGFuZykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzb2xhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdExhbmcgPSBkZWZhdWx0TGFuZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmUuZGVmYXVsdExhbmcgPSBkZWZhdWx0TGFuZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zbGF0ZVNlcnZpY2UucHJvdG90eXBlLCBcImN1cnJlbnRMYW5nXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGxhbmcgY3VycmVudGx5IHVzZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICAgICAqIFRoZSBsYW5nIGN1cnJlbnRseSB1c2VkXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc29sYXRlID8gdGhpcy5fY3VycmVudExhbmcgOiB0aGlzLnN0b3JlLmN1cnJlbnRMYW5nO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGN1cnJlbnRMYW5nXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovIGZ1bmN0aW9uIChjdXJyZW50TGFuZykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzb2xhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExhbmcgPSBjdXJyZW50TGFuZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmUuY3VycmVudExhbmcgPSBjdXJyZW50TGFuZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zbGF0ZVNlcnZpY2UucHJvdG90eXBlLCBcImxhbmdzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogYW4gYXJyYXkgb2YgbGFuZ3NcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICAgICAqIGFuIGFycmF5IG9mIGxhbmdzXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc29sYXRlID8gdGhpcy5fbGFuZ3MgOiB0aGlzLnN0b3JlLmxhbmdzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGxhbmdzXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovIGZ1bmN0aW9uIChsYW5ncykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzb2xhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFuZ3MgPSBsYW5ncztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmUubGFuZ3MgPSBsYW5ncztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zbGF0ZVNlcnZpY2UucHJvdG90eXBlLCBcInRyYW5zbGF0aW9uc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGEgbGlzdCBvZiB0cmFuc2xhdGlvbnMgcGVyIGxhbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiAvKipcbiAgICAgICAgICAgICAqIGEgbGlzdCBvZiB0cmFuc2xhdGlvbnMgcGVyIGxhbmdcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzb2xhdGUgPyB0aGlzLl90cmFuc2xhdGlvbnMgOiB0aGlzLnN0b3JlLnRyYW5zbGF0aW9ucztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSB0cmFuc2xhdGlvbnNcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi8gZnVuY3Rpb24gKHRyYW5zbGF0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzb2xhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRpb25zID0gdHJhbnNsYXRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yZS50cmFuc2xhdGlvbnMgPSB0cmFuc2xhdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSBkZWZhdWx0IGxhbmd1YWdlIHRvIHVzZSBhcyBhIGZhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgZGVmYXVsdCBsYW5ndWFnZSB0byB1c2UgYXMgYSBmYWxsYmFja1xuICAgICAgICAgKiBAcGFyYW0gez99IGxhbmdcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRyYW5zbGF0ZVNlcnZpY2UucHJvdG90eXBlLnNldERlZmF1bHRMYW5nID0gLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UgdG8gdXNlIGFzIGEgZmFsbGJhY2tcbiAgICAgICAgICogQHBhcmFtIHs/fSBsYW5nXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKGxhbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGlmIChsYW5nID09PSB0aGlzLmRlZmF1bHRMYW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgIHZhciBwZW5kaW5nID0gdGhpcy5yZXRyaWV2ZVRyYW5zbGF0aW9ucyhsYW5nKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBlbmRpbmcgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gaW5pdCBzZXQgdGhlIGRlZmF1bHRMYW5nIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5kZWZhdWx0TGFuZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0TGFuZyA9IGxhbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZy5waXBlKG9wZXJhdG9ycy50YWtlKDEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jaGFuZ2VEZWZhdWx0TGFuZyhsYW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyB3ZSBhbHJlYWR5IGhhdmUgdGhpcyBsYW5ndWFnZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURlZmF1bHRMYW5nKGxhbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IGxhbmd1YWdlIHVzZWRcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IGxhbmd1YWdlIHVzZWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRyYW5zbGF0ZVNlcnZpY2UucHJvdG90eXBlLmdldERlZmF1bHRMYW5nID0gLyoqXG4gICAgICAgICAqIEdldHMgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UgdXNlZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0TGFuZztcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2VzIHRoZSBsYW5nIGN1cnJlbnRseSB1c2VkXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgbGFuZyBjdXJyZW50bHkgdXNlZFxuICAgICAgICAgKiBAcGFyYW0gez99IGxhbmdcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRyYW5zbGF0ZVNlcnZpY2UucHJvdG90eXBlLnVzZSA9IC8qKlxuICAgICAgICAgKiBDaGFuZ2VzIHRoZSBsYW5nIGN1cnJlbnRseSB1c2VkXG4gICAgICAgICAqIEBwYXJhbSB7P30gbGFuZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChsYW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBjaGFuZ2UgdGhlIGxhbmd1YWdlIGlmIHRoZSBsYW5ndWFnZSBnaXZlbiBpcyBhbHJlYWR5IHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgaWYgKGxhbmcgPT09IHRoaXMuY3VycmVudExhbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMub2YodGhpcy50cmFuc2xhdGlvbnNbbGFuZ10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgdmFyIHBlbmRpbmcgPSB0aGlzLnJldHJpZXZlVHJhbnNsYXRpb25zKGxhbmcpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGVuZGluZyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBvbiBpbml0IHNldCB0aGUgY3VycmVudExhbmcgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRMYW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRMYW5nID0gbGFuZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nLnBpcGUob3BlcmF0b3JzLnRha2UoMSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNoYW5nZUxhbmcobGFuZyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGVuZGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIHdlIGhhdmUgdGhpcyBsYW5ndWFnZSwgcmV0dXJuIGFuIE9ic2VydmFibGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VMYW5nKGxhbmcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqcy5vZih0aGlzLnRyYW5zbGF0aW9uc1tsYW5nXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyB0aGUgZ2l2ZW4gdHJhbnNsYXRpb25zXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIHRoZSBnaXZlbiB0cmFuc2xhdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHs/fSBsYW5nXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUcmFuc2xhdGVTZXJ2aWNlLnByb3RvdHlwZS5yZXRyaWV2ZVRyYW5zbGF0aW9ucyA9IC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIGdpdmVuIHRyYW5zbGF0aW9uc1xuICAgICAgICAgKiBAcGFyYW0gez99IGxhbmdcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAobGFuZykge1xuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICB2YXIgcGVuZGluZztcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGxhbmd1YWdlIGlzIHVuYXZhaWxhYmxlLCBhc2sgZm9yIGl0XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRyYW5zbGF0aW9uc1tsYW5nXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvblJlcXVlc3RzW2xhbmddID0gdGhpcy5fdHJhbnNsYXRpb25SZXF1ZXN0c1tsYW5nXSB8fCB0aGlzLmdldFRyYW5zbGF0aW9uKGxhbmcpO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nID0gdGhpcy5fdHJhbnNsYXRpb25SZXF1ZXN0c1tsYW5nXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBlbmRpbmc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBhbiBvYmplY3Qgb2YgdHJhbnNsYXRpb25zIGZvciBhIGdpdmVuIGxhbmd1YWdlIHdpdGggdGhlIGN1cnJlbnQgbG9hZGVyXG4gICAgICAgICAqIGFuZCBwYXNzZXMgaXQgdGhyb3VnaCB0aGUgY29tcGlsZXJcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIGFuIG9iamVjdCBvZiB0cmFuc2xhdGlvbnMgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2Ugd2l0aCB0aGUgY3VycmVudCBsb2FkZXJcbiAgICAgICAgICogYW5kIHBhc3NlcyBpdCB0aHJvdWdoIHRoZSBjb21waWxlclxuICAgICAgICAgKiBAcGFyYW0gez99IGxhbmdcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRyYW5zbGF0ZVNlcnZpY2UucHJvdG90eXBlLmdldFRyYW5zbGF0aW9uID0gLyoqXG4gICAgICAgICAqIEdldHMgYW4gb2JqZWN0IG9mIHRyYW5zbGF0aW9ucyBmb3IgYSBnaXZlbiBsYW5ndWFnZSB3aXRoIHRoZSBjdXJyZW50IGxvYWRlclxuICAgICAgICAgKiBhbmQgcGFzc2VzIGl0IHRocm91Z2ggdGhlIGNvbXBpbGVyXG4gICAgICAgICAqIEBwYXJhbSB7P30gbGFuZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChsYW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICB2YXIgbG9hZGluZ1RyYW5zbGF0aW9ucyA9IHRoaXMuY3VycmVudExvYWRlci5nZXRUcmFuc2xhdGlvbihsYW5nKS5waXBlKG9wZXJhdG9ycy5zaGFyZSgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdUcmFuc2xhdGlvbnMgPSBsb2FkaW5nVHJhbnNsYXRpb25zLnBpcGUob3BlcmF0b3JzLnRha2UoMSksIG9wZXJhdG9ycy5tYXAoZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gX3RoaXMuY29tcGlsZXIuY29tcGlsZVRyYW5zbGF0aW9ucyhyZXMsIGxhbmcpOyB9KSwgb3BlcmF0b3JzLnNoYXJlKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZ1RyYW5zbGF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJhbnNsYXRpb25zW2xhbmddID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVMYW5ncygpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRpbmdUcmFuc2xhdGlvbnM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFudWFsbHkgc2V0cyBhbiBvYmplY3Qgb2YgdHJhbnNsYXRpb25zIGZvciBhIGdpdmVuIGxhbmd1YWdlXG4gICAgICAgICAqIGFmdGVyIHBhc3NpbmcgaXQgdGhyb3VnaCB0aGUgY29tcGlsZXJcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYW51YWxseSBzZXRzIGFuIG9iamVjdCBvZiB0cmFuc2xhdGlvbnMgZm9yIGEgZ2l2ZW4gbGFuZ3VhZ2VcbiAgICAgICAgICogYWZ0ZXIgcGFzc2luZyBpdCB0aHJvdWdoIHRoZSBjb21waWxlclxuICAgICAgICAgKiBAcGFyYW0gez99IGxhbmdcbiAgICAgICAgICogQHBhcmFtIHs/fSB0cmFuc2xhdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHs/PX0gc2hvdWxkTWVyZ2VcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRyYW5zbGF0ZVNlcnZpY2UucHJvdG90eXBlLnNldFRyYW5zbGF0aW9uID0gLyoqXG4gICAgICAgICAqIE1hbnVhbGx5IHNldHMgYW4gb2JqZWN0IG9mIHRyYW5zbGF0aW9ucyBmb3IgYSBnaXZlbiBsYW5ndWFnZVxuICAgICAgICAgKiBhZnRlciBwYXNzaW5nIGl0IHRocm91Z2ggdGhlIGNvbXBpbGVyXG4gICAgICAgICAqIEBwYXJhbSB7P30gbGFuZ1xuICAgICAgICAgKiBAcGFyYW0gez99IHRyYW5zbGF0aW9uc1xuICAgICAgICAgKiBAcGFyYW0gez89fSBzaG91bGRNZXJnZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChsYW5nLCB0cmFuc2xhdGlvbnMsIHNob3VsZE1lcmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZE1lcmdlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkTWVyZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25zID0gdGhpcy5jb21waWxlci5jb21waWxlVHJhbnNsYXRpb25zKHRyYW5zbGF0aW9ucywgbGFuZyk7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZE1lcmdlICYmIHRoaXMudHJhbnNsYXRpb25zW2xhbmddKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRpb25zW2xhbmddID0gbWVyZ2VEZWVwKHRoaXMudHJhbnNsYXRpb25zW2xhbmddLCB0cmFuc2xhdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2xhdGlvbnNbbGFuZ10gPSB0cmFuc2xhdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGFuZ3MoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVHJhbnNsYXRpb25DaGFuZ2UuZW1pdCh7IGxhbmc6IGxhbmcsIHRyYW5zbGF0aW9uczogdGhpcy50cmFuc2xhdGlvbnNbbGFuZ10gfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBjdXJyZW50bHkgYXZhaWxhYmxlIGxhbmdzXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBjdXJyZW50bHkgYXZhaWxhYmxlIGxhbmdzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUcmFuc2xhdGVTZXJ2aWNlLnByb3RvdHlwZS5nZXRMYW5ncyA9IC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGN1cnJlbnRseSBhdmFpbGFibGUgbGFuZ3NcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFuZ3M7XG4gICAgICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGF2YWlsYWJsZSBsYW5nc1xuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhdmFpbGFibGUgbGFuZ3NcbiAgICAgICAgICogQHBhcmFtIHs/fSBsYW5nc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVHJhbnNsYXRlU2VydmljZS5wcm90b3R5cGUuYWRkTGFuZ3MgPSAvKipcbiAgICAgICAgICogQWRkIGF2YWlsYWJsZSBsYW5nc1xuICAgICAgICAgKiBAcGFyYW0gez99IGxhbmdzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKGxhbmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICBsYW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChsYW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5sYW5ncy5pbmRleE9mKGxhbmcpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubGFuZ3MucHVzaChsYW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgbGlzdCBvZiBhdmFpbGFibGUgbGFuZ3NcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGxhbmdzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUcmFuc2xhdGVTZXJ2aWNlLnByb3RvdHlwZS51cGRhdGVMYW5ncyA9IC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGxhbmdzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTGFuZ3MoT2JqZWN0LmtleXModGhpcy50cmFuc2xhdGlvbnMpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwYXJzZWQgcmVzdWx0IG9mIHRoZSB0cmFuc2xhdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwYXJzZWQgcmVzdWx0IG9mIHRoZSB0cmFuc2xhdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHs/fSB0cmFuc2xhdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgICAgICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGVQYXJhbXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRyYW5zbGF0ZVNlcnZpY2UucHJvdG90eXBlLmdldFBhcnNlZFJlc3VsdCA9IC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwYXJzZWQgcmVzdWx0IG9mIHRoZSB0cmFuc2xhdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHs/fSB0cmFuc2xhdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgICAgICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGVQYXJhbXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAodHJhbnNsYXRpb25zLCBrZXksIGludGVycG9sYXRlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgIHZhciByZXM7XG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5XzEgPSBfX3ZhbHVlcyhrZXkpLCBrZXlfMV8xID0ga2V5XzEubmV4dCgpOyAha2V5XzFfMS5kb25lOyBrZXlfMV8xID0ga2V5XzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBrZXlfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrXSA9IHRoaXMuZ2V0UGFyc2VkUmVzdWx0KHRyYW5zbGF0aW9ucywgaywgaW50ZXJwb2xhdGVQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0W2tdLnN1YnNjcmliZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSB7IGVycm9yOiBlXzFfMSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5XzFfMSAmJiAha2V5XzFfMS5kb25lICYmIChfYSA9IGtleV8xLnJldHVybikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmNhbGwoa2V5XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYnNlcnZhYmxlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lcmdlZE9icyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5XzIgPSBfX3ZhbHVlcyhrZXkpLCBrZXlfMl8xID0ga2V5XzIubmV4dCgpOyAha2V5XzJfMS5kb25lOyBrZXlfMl8xID0ga2V5XzIubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0ga2V5XzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JzID0gdHlwZW9mIHJlc3VsdFtrXS5zdWJzY3JpYmUgPT09IFwiZnVuY3Rpb25cIiA/IHJlc3VsdFtrXSA6IHJ4anMub2YoKCAvKiogQHR5cGUgez99ICovKHJlc3VsdFtrXSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXJnZWRPYnMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZE9icyA9IG9icztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZE9icyA9IHJ4anMubWVyZ2UobWVyZ2VkT2JzLCBvYnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZV8yID0geyBlcnJvcjogZV8yXzEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlfMl8xICYmICFrZXlfMl8xLmRvbmUgJiYgKF9iID0ga2V5XzIucmV0dXJuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iLmNhbGwoa2V5XzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVfMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVfMi5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VkT2JzLnBpcGUob3BlcmF0b3JzLnRvQXJyYXkoKSwgb3BlcmF0b3JzLm1hcChmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnIuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXlbaW5kZXhdXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zbGF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSB0aGlzLnBhcnNlci5pbnRlcnBvbGF0ZSh0aGlzLnBhcnNlci5nZXRWYWx1ZSh0cmFuc2xhdGlvbnMsIGtleSksIGludGVycG9sYXRlUGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMgPT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5kZWZhdWx0TGFuZyAmJiB0aGlzLmRlZmF1bHRMYW5nICE9PSB0aGlzLmN1cnJlbnRMYW5nICYmIHRoaXMudXNlRGVmYXVsdExhbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gdGhpcy5wYXJzZXIuaW50ZXJwb2xhdGUodGhpcy5wYXJzZXIuZ2V0VmFsdWUodGhpcy50cmFuc2xhdGlvbnNbdGhpcy5kZWZhdWx0TGFuZ10sIGtleSksIGludGVycG9sYXRlUGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0geyBrZXk6IGtleSwgdHJhbnNsYXRlU2VydmljZTogdGhpcyB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGludGVycG9sYXRlUGFyYW1zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmludGVycG9sYXRlUGFyYW1zID0gaW50ZXJwb2xhdGVQYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzID0gdGhpcy5taXNzaW5nVHJhbnNsYXRpb25IYW5kbGVyLmhhbmRsZShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHJlcyAhPT0gXCJ1bmRlZmluZWRcIiA/IHJlcyA6IGtleTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB0cmFuc2xhdGVkIHZhbHVlIG9mIGEga2V5IChvciBhbiBhcnJheSBvZiBrZXlzKVxuICAgICAgICAgKiBAcmV0dXJucyB0aGUgdHJhbnNsYXRlZCBrZXksIG9yIGFuIG9iamVjdCBvZiB0cmFuc2xhdGVkIGtleXNcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB0cmFuc2xhdGVkIHZhbHVlIG9mIGEga2V5IChvciBhbiBhcnJheSBvZiBrZXlzKVxuICAgICAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAgICAgKiBAcGFyYW0gez89fSBpbnRlcnBvbGF0ZVBhcmFtc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fSB0aGUgdHJhbnNsYXRlZCBrZXksIG9yIGFuIG9iamVjdCBvZiB0cmFuc2xhdGVkIGtleXNcbiAgICAgICAgICovXG4gICAgICAgIFRyYW5zbGF0ZVNlcnZpY2UucHJvdG90eXBlLmdldCA9IC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB0cmFuc2xhdGVkIHZhbHVlIG9mIGEga2V5IChvciBhbiBhcnJheSBvZiBrZXlzKVxuICAgICAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAgICAgKiBAcGFyYW0gez89fSBpbnRlcnBvbGF0ZVBhcmFtc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fSB0aGUgdHJhbnNsYXRlZCBrZXksIG9yIGFuIG9iamVjdCBvZiB0cmFuc2xhdGVkIGtleXNcbiAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoa2V5LCBpbnRlcnBvbGF0ZVBhcmFtcykge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0RlZmluZWQoa2V5KSB8fCAha2V5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgXFxcImtleVxcXCIgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBsb2FkaW5nIGEgbmV3IHRyYW5zbGF0aW9uIHRvIHVzZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMuT2JzZXJ2YWJsZS5jcmVhdGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25Db21wbGV0ZSA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvYWRpbmdUcmFuc2xhdGlvbnMuc3Vic2NyaWJlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBfdGhpcy5nZXRQYXJzZWRSZXN1bHQocmVzLCBrZXksIGludGVycG9sYXRlUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcy5zdWJzY3JpYmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMuc3Vic2NyaWJlKG9uQ29tcGxldGUsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZShyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuZ2V0UGFyc2VkUmVzdWx0KHRoaXMudHJhbnNsYXRpb25zW3RoaXMuY3VycmVudExhbmddLCBrZXksIGludGVycG9sYXRlUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMuc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnhqcy5vZihyZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJlYW0gb2YgdHJhbnNsYXRlZCB2YWx1ZXMgb2YgYSBrZXkgKG9yIGFuIGFycmF5IG9mIGtleXMpIHdoaWNoIHVwZGF0ZXNcbiAgICAgICAgICogd2hlbmV2ZXIgdGhlIGxhbmd1YWdlIGNoYW5nZXMuXG4gICAgICAgICAqIEByZXR1cm5zIEEgc3RyZWFtIG9mIHRoZSB0cmFuc2xhdGVkIGtleSwgb3IgYW4gb2JqZWN0IG9mIHRyYW5zbGF0ZWQga2V5c1xuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJlYW0gb2YgdHJhbnNsYXRlZCB2YWx1ZXMgb2YgYSBrZXkgKG9yIGFuIGFycmF5IG9mIGtleXMpIHdoaWNoIHVwZGF0ZXNcbiAgICAgICAgICogd2hlbmV2ZXIgdGhlIGxhbmd1YWdlIGNoYW5nZXMuXG4gICAgICAgICAqIEBwYXJhbSB7P30ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGludGVycG9sYXRlUGFyYW1zXG4gICAgICAgICAqIEByZXR1cm4gez99IEEgc3RyZWFtIG9mIHRoZSB0cmFuc2xhdGVkIGtleSwgb3IgYW4gb2JqZWN0IG9mIHRyYW5zbGF0ZWQga2V5c1xuICAgICAgICAgKi9cbiAgICAgICAgVHJhbnNsYXRlU2VydmljZS5wcm90b3R5cGUuc3RyZWFtID0gLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBzdHJlYW0gb2YgdHJhbnNsYXRlZCB2YWx1ZXMgb2YgYSBrZXkgKG9yIGFuIGFycmF5IG9mIGtleXMpIHdoaWNoIHVwZGF0ZXNcbiAgICAgICAgICogd2hlbmV2ZXIgdGhlIGxhbmd1YWdlIGNoYW5nZXMuXG4gICAgICAgICAqIEBwYXJhbSB7P30ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGludGVycG9sYXRlUGFyYW1zXG4gICAgICAgICAqIEByZXR1cm4gez99IEEgc3RyZWFtIG9mIHRoZSB0cmFuc2xhdGVkIGtleSwgb3IgYW4gb2JqZWN0IG9mIHRyYW5zbGF0ZWQga2V5c1xuICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChrZXksIGludGVycG9sYXRlUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoIWlzRGVmaW5lZChrZXkpIHx8ICFrZXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBcXFwia2V5XFxcIiByZXF1aXJlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ4anMuY29uY2F0KHRoaXMuZ2V0KGtleSwgaW50ZXJwb2xhdGVQYXJhbXMpLCB0aGlzLm9uTGFuZ0NoYW5nZS5waXBlKG9wZXJhdG9ycy5zd2l0Y2hNYXAoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IF90aGlzLmdldFBhcnNlZFJlc3VsdChldmVudC50cmFuc2xhdGlvbnMsIGtleSwgaW50ZXJwb2xhdGVQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcy5zdWJzY3JpYmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByeGpzLm9mKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSB0cmFuc2xhdGlvbiBpbnN0YW50bHkgZnJvbSB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgbG9hZGVkIHRyYW5zbGF0aW9uLlxuICAgICAgICAgKiBBbGwgcnVsZXMgcmVnYXJkaW5nIHRoZSBjdXJyZW50IGxhbmd1YWdlLCB0aGUgcHJlZmVycmVkIGxhbmd1YWdlIG9mIGV2ZW4gZmFsbGJhY2sgbGFuZ3VhZ2VzIHdpbGwgYmUgdXNlZCBleGNlcHQgYW55IHByb21pc2UgaGFuZGxpbmcuXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHRyYW5zbGF0aW9uIGluc3RhbnRseSBmcm9tIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBsb2FkZWQgdHJhbnNsYXRpb24uXG4gICAgICAgICAqIEFsbCBydWxlcyByZWdhcmRpbmcgdGhlIGN1cnJlbnQgbGFuZ3VhZ2UsIHRoZSBwcmVmZXJyZWQgbGFuZ3VhZ2Ugb2YgZXZlbiBmYWxsYmFjayBsYW5ndWFnZXMgd2lsbCBiZSB1c2VkIGV4Y2VwdCBhbnkgcHJvbWlzZSBoYW5kbGluZy5cbiAgICAgICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgICAgICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGVQYXJhbXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRyYW5zbGF0ZVNlcnZpY2UucHJvdG90eXBlLmluc3RhbnQgPSAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHRyYW5zbGF0aW9uIGluc3RhbnRseSBmcm9tIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiBsb2FkZWQgdHJhbnNsYXRpb24uXG4gICAgICAgICAqIEFsbCBydWxlcyByZWdhcmRpbmcgdGhlIGN1cnJlbnQgbGFuZ3VhZ2UsIHRoZSBwcmVmZXJyZWQgbGFuZ3VhZ2Ugb2YgZXZlbiBmYWxsYmFjayBsYW5ndWFnZXMgd2lsbCBiZSB1c2VkIGV4Y2VwdCBhbnkgcHJvbWlzZSBoYW5kbGluZy5cbiAgICAgICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgICAgICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGVQYXJhbXNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoa2V5LCBpbnRlcnBvbGF0ZVBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmICghaXNEZWZpbmVkKGtleSkgfHwgIWtleS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyYW1ldGVyIFxcXCJrZXlcXFwiIHJlcXVpcmVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMuZ2V0UGFyc2VkUmVzdWx0KHRoaXMudHJhbnNsYXRpb25zW3RoaXMuY3VycmVudExhbmddLCBrZXksIGludGVycG9sYXRlUGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcy5zdWJzY3JpYmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqXzEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpfMVtrZXlbaW5kZXhdXSA9IGtleVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpfMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgdHJhbnNsYXRlZCB2YWx1ZSBvZiBhIGtleSwgYWZ0ZXIgY29tcGlsaW5nIGl0XG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgdHJhbnNsYXRlZCB2YWx1ZSBvZiBhIGtleSwgYWZ0ZXIgY29tcGlsaW5nIGl0XG4gICAgICAgICAqIEBwYXJhbSB7P30ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHs/PX0gbGFuZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVHJhbnNsYXRlU2VydmljZS5wcm90b3R5cGUuc2V0ID0gLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHRyYW5zbGF0ZWQgdmFsdWUgb2YgYSBrZXksIGFmdGVyIGNvbXBpbGluZyBpdFxuICAgICAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGxhbmdcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgbGFuZykge1xuICAgICAgICAgICAgICAgIGlmIChsYW5nID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZyA9IHRoaXMuY3VycmVudExhbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRpb25zW2xhbmddW2tleV0gPSB0aGlzLmNvbXBpbGVyLmNvbXBpbGUodmFsdWUsIGxhbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGFuZ3MoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uVHJhbnNsYXRpb25DaGFuZ2UuZW1pdCh7IGxhbmc6IGxhbmcsIHRyYW5zbGF0aW9uczogdGhpcy50cmFuc2xhdGlvbnNbbGFuZ10gfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgY3VycmVudCBsYW5nXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgY3VycmVudCBsYW5nXG4gICAgICAgICAqIEBwYXJhbSB7P30gbGFuZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVHJhbnNsYXRlU2VydmljZS5wcm90b3R5cGUuY2hhbmdlTGFuZyA9IC8qKlxuICAgICAgICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50IGxhbmdcbiAgICAgICAgICogQHBhcmFtIHs/fSBsYW5nXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKGxhbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRMYW5nID0gbGFuZztcbiAgICAgICAgICAgICAgICB0aGlzLm9uTGFuZ0NoYW5nZS5lbWl0KHsgbGFuZzogbGFuZywgdHJhbnNsYXRpb25zOiB0aGlzLnRyYW5zbGF0aW9uc1tsYW5nXSB9KTtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBkZWZhdWx0IGxhbmcsIHVzZSB0aGUgb25lIHRoYXQgd2UganVzdCBzZXRcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVmYXVsdExhbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZWZhdWx0TGFuZyhsYW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgZGVmYXVsdCBsYW5nXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgZGVmYXVsdCBsYW5nXG4gICAgICAgICAqIEBwYXJhbSB7P30gbGFuZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVHJhbnNsYXRlU2VydmljZS5wcm90b3R5cGUuY2hhbmdlRGVmYXVsdExhbmcgPSAvKipcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgZGVmYXVsdCBsYW5nXG4gICAgICAgICAqIEBwYXJhbSB7P30gbGFuZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChsYW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0TGFuZyA9IGxhbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRlZmF1bHRMYW5nQ2hhbmdlLmVtaXQoeyBsYW5nOiBsYW5nLCB0cmFuc2xhdGlvbnM6IHRoaXMudHJhbnNsYXRpb25zW2xhbmddIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbG93cyB0byByZWxvYWQgdGhlIGxhbmcgZmlsZSBmcm9tIHRoZSBmaWxlXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dzIHRvIHJlbG9hZCB0aGUgbGFuZyBmaWxlIGZyb20gdGhlIGZpbGVcbiAgICAgICAgICogQHBhcmFtIHs/fSBsYW5nXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUcmFuc2xhdGVTZXJ2aWNlLnByb3RvdHlwZS5yZWxvYWRMYW5nID0gLyoqXG4gICAgICAgICAqIEFsbG93cyB0byByZWxvYWQgdGhlIGxhbmcgZmlsZSBmcm9tIHRoZSBmaWxlXG4gICAgICAgICAqIEBwYXJhbSB7P30gbGFuZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChsYW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldExhbmcobGFuZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNsYXRpb24obGFuZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyBpbm5lciB0cmFuc2xhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZXMgaW5uZXIgdHJhbnNsYXRpb25cbiAgICAgICAgICogQHBhcmFtIHs/fSBsYW5nXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUcmFuc2xhdGVTZXJ2aWNlLnByb3RvdHlwZS5yZXNldExhbmcgPSAvKipcbiAgICAgICAgICogRGVsZXRlcyBpbm5lciB0cmFuc2xhdGlvblxuICAgICAgICAgKiBAcGFyYW0gez99IGxhbmdcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAobGFuZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uUmVxdWVzdHNbbGFuZ10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2xhdGlvbnNbbGFuZ10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbGFuZ3VhZ2UgY29kZSBuYW1lIGZyb20gdGhlIGJyb3dzZXIsIGUuZy4gXCJkZVwiXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbGFuZ3VhZ2UgY29kZSBuYW1lIGZyb20gdGhlIGJyb3dzZXIsIGUuZy4gXCJkZVwiXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUcmFuc2xhdGVTZXJ2aWNlLnByb3RvdHlwZS5nZXRCcm93c2VyTGFuZyA9IC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBsYW5ndWFnZSBjb2RlIG5hbWUgZnJvbSB0aGUgYnJvd3NlciwgZS5nLiBcImRlXCJcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgdmFyIGJyb3dzZXJMYW5nID0gd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZXMgPyB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlc1swXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgYnJvd3NlckxhbmcgPSBicm93c2VyTGFuZyB8fCB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlIHx8IHdpbmRvdy5uYXZpZ2F0b3IuYnJvd3Nlckxhbmd1YWdlIHx8IHdpbmRvdy5uYXZpZ2F0b3IudXNlckxhbmd1YWdlO1xuICAgICAgICAgICAgICAgIGlmIChicm93c2VyTGFuZy5pbmRleE9mKCctJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXJMYW5nID0gYnJvd3Nlckxhbmcuc3BsaXQoJy0nKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJyb3dzZXJMYW5nLmluZGV4T2YoJ18nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJvd3NlckxhbmcgPSBicm93c2VyTGFuZy5zcGxpdCgnXycpWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3Nlckxhbmc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VsdHVyZSBsYW5ndWFnZSBjb2RlIG5hbWUgZnJvbSB0aGUgYnJvd3NlciwgZS5nLiBcImRlLURFXCJcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdWx0dXJlIGxhbmd1YWdlIGNvZGUgbmFtZSBmcm9tIHRoZSBicm93c2VyLCBlLmcuIFwiZGUtREVcIlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVHJhbnNsYXRlU2VydmljZS5wcm90b3R5cGUuZ2V0QnJvd3NlckN1bHR1cmVMYW5nID0gLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1bHR1cmUgbGFuZ3VhZ2UgY29kZSBuYW1lIGZyb20gdGhlIGJyb3dzZXIsIGUuZy4gXCJkZS1ERVwiXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgIHZhciBicm93c2VyQ3VsdHVyZUxhbmcgPSB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlcyA/IHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBicm93c2VyQ3VsdHVyZUxhbmcgPSBicm93c2VyQ3VsdHVyZUxhbmcgfHwgd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZSB8fCB3aW5kb3cubmF2aWdhdG9yLmJyb3dzZXJMYW5ndWFnZSB8fCB3aW5kb3cubmF2aWdhdG9yLnVzZXJMYW5ndWFnZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvd3NlckN1bHR1cmVMYW5nO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgVHJhbnNsYXRlU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBjb3JlLkluamVjdGFibGUgfVxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgVHJhbnNsYXRlU2VydmljZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUcmFuc2xhdGVTdG9yZSB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogVHJhbnNsYXRlTG9hZGVyIH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBUcmFuc2xhdGVDb21waWxlciB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogVHJhbnNsYXRlUGFyc2VyIH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBNaXNzaW5nVHJhbnNsYXRpb25IYW5kbGVyIH0sXG4gICAgICAgICAgICAgICAgeyB0eXBlOiBCb29sZWFuLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBjb3JlLkluamVjdCwgYXJnczogW1VTRV9ERUZBVUxUX0xBTkcsXSB9XSB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogQm9vbGVhbiwgZGVjb3JhdG9yczogW3sgdHlwZTogY29yZS5JbmplY3QsIGFyZ3M6IFtVU0VfU1RPUkUsXSB9XSB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVHJhbnNsYXRlU2VydmljZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gICAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAgICAgKi9cbiAgICB2YXIgVHJhbnNsYXRlRGlyZWN0aXZlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUcmFuc2xhdGVEaXJlY3RpdmUodHJhbnNsYXRlU2VydmljZSwgZWxlbWVudCwgX3JlZikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlU2VydmljZSA9IHRyYW5zbGF0ZVNlcnZpY2U7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5fcmVmID0gX3JlZjtcbiAgICAgICAgICAgIC8vIHN1YnNjcmliZSB0byBvblRyYW5zbGF0aW9uQ2hhbmdlIGV2ZW50LCBpbiBjYXNlIHRoZSB0cmFuc2xhdGlvbnMgb2YgdGhlIGN1cnJlbnQgbGFuZyBjaGFuZ2VcbiAgICAgICAgICAgIGlmICghdGhpcy5vblRyYW5zbGF0aW9uQ2hhbmdlU3ViKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblRyYW5zbGF0aW9uQ2hhbmdlU3ViID0gdGhpcy50cmFuc2xhdGVTZXJ2aWNlLm9uVHJhbnNsYXRpb25DaGFuZ2Uuc3Vic2NyaWJlKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQubGFuZyA9PT0gX3RoaXMudHJhbnNsYXRlU2VydmljZS5jdXJyZW50TGFuZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tOb2Rlcyh0cnVlLCBldmVudC50cmFuc2xhdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdWJzY3JpYmUgdG8gb25MYW5nQ2hhbmdlIGV2ZW50LCBpbiBjYXNlIHRoZSBsYW5ndWFnZSBjaGFuZ2VzXG4gICAgICAgICAgICBpZiAoIXRoaXMub25MYW5nQ2hhbmdlU3ViKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkxhbmdDaGFuZ2VTdWIgPSB0aGlzLnRyYW5zbGF0ZVNlcnZpY2Uub25MYW5nQ2hhbmdlLnN1YnNjcmliZShmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tOb2Rlcyh0cnVlLCBldmVudC50cmFuc2xhdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3Vic2NyaWJlIHRvIG9uRGVmYXVsdExhbmdDaGFuZ2UgZXZlbnQsIGluIGNhc2UgdGhlIGRlZmF1bHQgbGFuZ3VhZ2UgY2hhbmdlc1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9uRGVmYXVsdExhbmdDaGFuZ2VTdWIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGVmYXVsdExhbmdDaGFuZ2VTdWIgPSB0aGlzLnRyYW5zbGF0ZVNlcnZpY2Uub25EZWZhdWx0TGFuZ0NoYW5nZS5zdWJzY3JpYmUoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrTm9kZXModHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zbGF0ZURpcmVjdGl2ZS5wcm90b3R5cGUsIFwidHJhbnNsYXRlXCIsIHtcbiAgICAgICAgICAgIHNldDogLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqLyBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja05vZGVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2xhdGVEaXJlY3RpdmUucHJvdG90eXBlLCBcInRyYW5zbGF0ZVBhcmFtc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIHs/fSBwYXJhbXNcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi8gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgICAgIGlmICghZXF1YWxzKHRoaXMuY3VycmVudFBhcmFtcywgcGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tOb2Rlcyh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUcmFuc2xhdGVEaXJlY3RpdmUucHJvdG90eXBlLm5nQWZ0ZXJWaWV3Q2hlY2tlZCA9IC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrTm9kZXMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez89fSBmb3JjZVVwZGF0ZVxuICAgICAgICAgKiBAcGFyYW0gez89fSB0cmFuc2xhdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRyYW5zbGF0ZURpcmVjdGl2ZS5wcm90b3R5cGUuY2hlY2tOb2RlcyA9IC8qKlxuICAgICAgICAgKiBAcGFyYW0gez89fSBmb3JjZVVwZGF0ZVxuICAgICAgICAgKiBAcGFyYW0gez89fSB0cmFuc2xhdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoZm9yY2VVcGRhdGUsIHRyYW5zbGF0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JjZVVwZGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGlzIGVtcHR5XG4gICAgICAgICAgICAgICAgaWYgKCFub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgYWRkIHRoZSBrZXkgYXMgY29udGVudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldENvbnRlbnQodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIHRoaXMua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHsgLy8gbm9kZSB0eXBlIDMgaXMgYSB0ZXh0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vZGUgdHlwZSAzIGlzIGEgdGV4dCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gdGhpcy5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubGFzdEtleSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJpbW1lZENvbnRlbnQgPSBjb250ZW50LnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJpbW1lZENvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gdXNlIHRoZSBjb250ZW50IGFzIGEga2V5LCBub3QgdGhlIHRyYW5zbGF0aW9uIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50ICE9PSBub2RlLmN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gdHJpbW1lZENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY29udGVudCB3YXMgY2hhbmdlZCBmcm9tIHRoZSB1c2VyLCB3ZSdsbCB1c2UgaXQgYXMgYSByZWZlcmVuY2UgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm9yaWdpbmFsQ29udGVudCA9IHRoaXMuZ2V0Q29udGVudChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLm9yaWdpbmFsQ29udGVudCAmJiBmb3JjZVVwZGF0ZSkgeyAvLyB0aGUgY29udGVudCBzZWVtcyBvaywgYnV0IHRoZSBsYW5nIGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxhc3RLZXkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgY29udGVudCBpcyB0aGUgdHJhbnNsYXRpb24sIG5vdCB0aGUga2V5LCB1c2UgdGhlIGxhc3QgcmVhbCBjb250ZW50IGFzIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gbm9kZS5vcmlnaW5hbENvbnRlbnQudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZShrZXksIG5vZGUsIHRyYW5zbGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICAgICAqIEBwYXJhbSB7P30gdHJhbnNsYXRpb25zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUcmFuc2xhdGVEaXJlY3RpdmUucHJvdG90eXBlLnVwZGF0ZVZhbHVlID0gLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30ga2V5XG4gICAgICAgICAqIEBwYXJhbSB7P30gbm9kZVxuICAgICAgICAgKiBAcGFyYW0gez99IHRyYW5zbGF0aW9uc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChrZXksIG5vZGUsIHRyYW5zbGF0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sYXN0S2V5ID09PSBrZXkgJiYgdGhpcy5sYXN0UGFyYW1zID09PSB0aGlzLmN1cnJlbnRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RQYXJhbXMgPSB0aGlzLmN1cnJlbnRQYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uVHJhbnNsYXRpb24gPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxhc3RLZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUub3JpZ2luYWxDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5vcmlnaW5hbENvbnRlbnQgPSBfdGhpcy5nZXRDb250ZW50KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jdXJyZW50VmFsdWUgPSBpc0RlZmluZWQocmVzKSA/IHJlcyA6IChub2RlLm9yaWdpbmFsQ29udGVudCB8fCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBpbiB0aGUgb3JpZ2luYWwgY29udGVudCB0byBwcmVzZXJ2ZSBzcGFjZXMgdGhhdCB3ZSBtaWdodCBoYXZlIHRyaW1tZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldENvbnRlbnQobm9kZSwgX3RoaXMua2V5ID8gbm9kZS5jdXJyZW50VmFsdWUgOiBub2RlLm9yaWdpbmFsQ29udGVudC5yZXBsYWNlKGtleSwgbm9kZS5jdXJyZW50VmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQodHJhbnNsYXRpb25zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMudHJhbnNsYXRlU2VydmljZS5nZXRQYXJzZWRSZXN1bHQodHJhbnNsYXRpb25zLCBrZXksIHRoaXMuY3VycmVudFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcy5zdWJzY3JpYmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5zdWJzY3JpYmUob25UcmFuc2xhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblRyYW5zbGF0aW9uKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zbGF0ZVNlcnZpY2UuZ2V0KGtleSwgdGhpcy5jdXJyZW50UGFyYW1zKS5zdWJzY3JpYmUob25UcmFuc2xhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUcmFuc2xhdGVEaXJlY3RpdmUucHJvdG90eXBlLmdldENvbnRlbnQgPSAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNEZWZpbmVkKG5vZGUudGV4dENvbnRlbnQpID8gbm9kZS50ZXh0Q29udGVudCA6IG5vZGUuZGF0YTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHs/fSBjb250ZW50XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUcmFuc2xhdGVEaXJlY3RpdmUucHJvdG90eXBlLnNldENvbnRlbnQgPSAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29udGVudFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChub2RlLCBjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmaW5lZChub2RlLnRleHRDb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUcmFuc2xhdGVEaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uTGFuZ0NoYW5nZVN1Yikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTGFuZ0NoYW5nZVN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbkRlZmF1bHRMYW5nQ2hhbmdlU3ViKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25EZWZhdWx0TGFuZ0NoYW5nZVN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vblRyYW5zbGF0aW9uQ2hhbmdlU3ViKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25UcmFuc2xhdGlvbkNoYW5nZVN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIFRyYW5zbGF0ZURpcmVjdGl2ZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBjb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW3RyYW5zbGF0ZV0sW25neC10cmFuc2xhdGVdJ1xuICAgICAgICAgICAgICAgICAgICB9LF0gfVxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgVHJhbnNsYXRlRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7IHR5cGU6IFRyYW5zbGF0ZVNlcnZpY2UgfSxcbiAgICAgICAgICAgICAgICB7IHR5cGU6IGNvcmUuRWxlbWVudFJlZiB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogY29yZS5DaGFuZ2VEZXRlY3RvclJlZiB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9O1xuICAgICAgICBUcmFuc2xhdGVEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICB0cmFuc2xhdGU6IFt7IHR5cGU6IGNvcmUuSW5wdXQgfV0sXG4gICAgICAgICAgICB0cmFuc2xhdGVQYXJhbXM6IFt7IHR5cGU6IGNvcmUuSW5wdXQgfV1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRyYW5zbGF0ZURpcmVjdGl2ZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gICAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAgICAgKi9cbiAgICB2YXIgVHJhbnNsYXRlUGlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVHJhbnNsYXRlUGlwZSh0cmFuc2xhdGUsIF9yZWYpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuICAgICAgICAgICAgdGhpcy5fcmVmID0gX3JlZjtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBrZXlcbiAgICAgICAgICogQHBhcmFtIHs/PX0gaW50ZXJwb2xhdGVQYXJhbXNcbiAgICAgICAgICogQHBhcmFtIHs/PX0gdHJhbnNsYXRpb25zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBUcmFuc2xhdGVQaXBlLnByb3RvdHlwZS51cGRhdGVWYWx1ZSA9IC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGtleVxuICAgICAgICAgKiBAcGFyYW0gez89fSBpbnRlcnBvbGF0ZVBhcmFtc1xuICAgICAgICAgKiBAcGFyYW0gez89fSB0cmFuc2xhdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoa2V5LCBpbnRlcnBvbGF0ZVBhcmFtcywgdHJhbnNsYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgdmFyIG9uVHJhbnNsYXRpb24gPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlID0gcmVzICE9PSB1bmRlZmluZWQgPyByZXMgOiBrZXk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxhc3RLZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHRoaXMudHJhbnNsYXRlLmdldFBhcnNlZFJlc3VsdCh0cmFuc2xhdGlvbnMsIGtleSwgaW50ZXJwb2xhdGVQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcy5zdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5zdWJzY3JpYmUob25UcmFuc2xhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblRyYW5zbGF0aW9uKHJlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2xhdGUuZ2V0KGtleSwgaW50ZXJwb2xhdGVQYXJhbXMpLnN1YnNjcmliZShvblRyYW5zbGF0aW9uKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHF1ZXJ5XG4gICAgICAgICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVHJhbnNsYXRlUGlwZS5wcm90b3R5cGUudHJhbnNmb3JtID0gLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcXVlcnlcbiAgICAgICAgICogQHBhcmFtIHsuLi4/fSBhcmdzXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcXVlcnkgfHwgcXVlcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXNrIGFub3RoZXIgdGltZSBmb3IgdGhlIHNhbWUga2V5LCByZXR1cm4gdGhlIGxhc3QgdmFsdWVcbiAgICAgICAgICAgICAgICBpZiAoZXF1YWxzKHF1ZXJ5LCB0aGlzLmxhc3RLZXkpICYmIGVxdWFscyhhcmdzLCB0aGlzLmxhc3RQYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICAgICAgdmFyIGludGVycG9sYXRlUGFyYW1zO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQoYXJnc1swXSkgJiYgYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyAmJiBhcmdzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYWNjZXB0IG9iamVjdHMgd3JpdHRlbiBpbiB0aGUgdGVtcGxhdGUgc3VjaCBhcyB7bjoxfSwgeyduJzoxfSwge246J3YnfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgd2h5IHdlIG1pZ2h0IG5lZWQgdG8gY2hhbmdlIGl0IHRvIHJlYWwgSlNPTiBvYmplY3RzIHN1Y2ggYXMge1wiblwiOjF9IG9yIHtcIm5cIjpcInZcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZEFyZ3MgPSBhcmdzWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyhcXCcpPyhbYS16QS1aMC05X10rKShcXCcpPyhcXHMpPzovZywgJ1wiJDJcIjonKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC86KFxccyk/KFxcJykoLio/KShcXCcpL2csICc6XCIkM1wiJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRlUGFyYW1zID0gSlNPTi5wYXJzZSh2YWxpZEFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJXcm9uZyBwYXJhbWV0ZXIgaW4gVHJhbnNsYXRlUGlwZS4gRXhwZWN0ZWQgYSB2YWxpZCBPYmplY3QsIHJlY2VpdmVkOiBcIiArIGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVQYXJhbXMgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBxdWVyeSwgaW4gY2FzZSBpdCBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0S2V5ID0gcXVlcnk7XG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgdGhlIHBhcmFtcywgaW4gY2FzZSB0aGV5IGNoYW5nZVxuICAgICAgICAgICAgICAgIHRoaXMubGFzdFBhcmFtcyA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUocXVlcnksIGludGVycG9sYXRlUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHN1YnNjcmlwdGlvbiB0byBvbkxhbmdDaGFuZ2UsIGNsZWFuIGl0XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIC8vIHN1YnNjcmliZSB0byBvblRyYW5zbGF0aW9uQ2hhbmdlIGV2ZW50LCBpbiBjYXNlIHRoZSB0cmFuc2xhdGlvbnMgY2hhbmdlXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9uVHJhbnNsYXRpb25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblRyYW5zbGF0aW9uQ2hhbmdlID0gdGhpcy50cmFuc2xhdGUub25UcmFuc2xhdGlvbkNoYW5nZS5zdWJzY3JpYmUoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGFzdEtleSAmJiBldmVudC5sYW5nID09PSBfdGhpcy50cmFuc2xhdGUuY3VycmVudExhbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5sYXN0S2V5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVWYWx1ZShxdWVyeSwgaW50ZXJwb2xhdGVQYXJhbXMsIGV2ZW50LnRyYW5zbGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzdWJzY3JpYmUgdG8gb25MYW5nQ2hhbmdlIGV2ZW50LCBpbiBjYXNlIHRoZSBsYW5ndWFnZSBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9uTGFuZ0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTGFuZ0NoYW5nZSA9IHRoaXMudHJhbnNsYXRlLm9uTGFuZ0NoYW5nZS5zdWJzY3JpYmUoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGFzdEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxhc3RLZXkgPSBudWxsOyAvLyB3ZSB3YW50IHRvIG1ha2Ugc3VyZSBpdCBkb2Vzbid0IHJldHVybiB0aGUgc2FtZSB2YWx1ZSB1bnRpbCBpdCdzIGJlZW4gdXBkYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVZhbHVlKHF1ZXJ5LCBpbnRlcnBvbGF0ZVBhcmFtcywgZXZlbnQudHJhbnNsYXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHN1YnNjcmliZSB0byBvbkRlZmF1bHRMYW5nQ2hhbmdlIGV2ZW50LCBpbiBjYXNlIHRoZSBkZWZhdWx0IGxhbmd1YWdlIGNoYW5nZXNcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub25EZWZhdWx0TGFuZ0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRGVmYXVsdExhbmdDaGFuZ2UgPSB0aGlzLnRyYW5zbGF0ZS5vbkRlZmF1bHRMYW5nQ2hhbmdlLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGFzdEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxhc3RLZXkgPSBudWxsOyAvLyB3ZSB3YW50IHRvIG1ha2Ugc3VyZSBpdCBkb2Vzbid0IHJldHVybiB0aGUgc2FtZSB2YWx1ZSB1bnRpbCBpdCdzIGJlZW4gdXBkYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVZhbHVlKHF1ZXJ5LCBpbnRlcnBvbGF0ZVBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhbiBhbnkgZXhpc3Rpbmcgc3Vic2NyaXB0aW9uIHRvIGNoYW5nZSBldmVudHNcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhbiBhbnkgZXhpc3Rpbmcgc3Vic2NyaXB0aW9uIHRvIGNoYW5nZSBldmVudHNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFRyYW5zbGF0ZVBpcGUucHJvdG90eXBlLl9kaXNwb3NlID0gLyoqXG4gICAgICAgICAqIENsZWFuIGFueSBleGlzdGluZyBzdWJzY3JpcHRpb24gdG8gY2hhbmdlIGV2ZW50c1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub25UcmFuc2xhdGlvbkNoYW5nZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblRyYW5zbGF0aW9uQ2hhbmdlLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25UcmFuc2xhdGlvbkNoYW5nZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uTGFuZ0NoYW5nZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkxhbmdDaGFuZ2UudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkxhbmdDaGFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbkRlZmF1bHRMYW5nQ2hhbmdlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRGVmYXVsdExhbmdDaGFuZ2UudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkRlZmF1bHRMYW5nQ2hhbmdlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVHJhbnNsYXRlUGlwZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgVHJhbnNsYXRlUGlwZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBjb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgICAgIHsgdHlwZTogY29yZS5QaXBlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3RyYW5zbGF0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdXJlOiBmYWxzZSAvLyByZXF1aXJlZCB0byB1cGRhdGUgdGhlIHZhbHVlIHdoZW4gdGhlIHByb21pc2UgaXMgcmVzb2x2ZWRcbiAgICAgICAgICAgICAgICAgICAgfSxdIH1cbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIFRyYW5zbGF0ZVBpcGUuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogVHJhbnNsYXRlU2VydmljZSB9LFxuICAgICAgICAgICAgICAgIHsgdHlwZTogY29yZS5DaGFuZ2VEZXRlY3RvclJlZiB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVHJhbnNsYXRlUGlwZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gICAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAgICAgKi9cbiAgICB2YXIgVHJhbnNsYXRlTW9kdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUcmFuc2xhdGVNb2R1bGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSB0aGlzIG1ldGhvZCBpbiB5b3VyIHJvb3QgbW9kdWxlIHRvIHByb3ZpZGUgdGhlIFRyYW5zbGF0ZVNlcnZpY2VcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgdGhpcyBtZXRob2QgaW4geW91ciByb290IG1vZHVsZSB0byBwcm92aWRlIHRoZSBUcmFuc2xhdGVTZXJ2aWNlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGNvbmZpZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVHJhbnNsYXRlTW9kdWxlLmZvclJvb3QgPSAvKipcbiAgICAgICAgICogVXNlIHRoaXMgbWV0aG9kIGluIHlvdXIgcm9vdCBtb2R1bGUgdG8gcHJvdmlkZSB0aGUgVHJhbnNsYXRlU2VydmljZVxuICAgICAgICAgKiBAcGFyYW0gez89fSBjb25maWdcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuZ01vZHVsZTogVHJhbnNsYXRlTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5sb2FkZXIgfHwgeyBwcm92aWRlOiBUcmFuc2xhdGVMb2FkZXIsIHVzZUNsYXNzOiBUcmFuc2xhdGVGYWtlTG9hZGVyIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuY29tcGlsZXIgfHwgeyBwcm92aWRlOiBUcmFuc2xhdGVDb21waWxlciwgdXNlQ2xhc3M6IFRyYW5zbGF0ZUZha2VDb21waWxlciB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnBhcnNlciB8fCB7IHByb3ZpZGU6IFRyYW5zbGF0ZVBhcnNlciwgdXNlQ2xhc3M6IFRyYW5zbGF0ZURlZmF1bHRQYXJzZXIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5taXNzaW5nVHJhbnNsYXRpb25IYW5kbGVyIHx8IHsgcHJvdmlkZTogTWlzc2luZ1RyYW5zbGF0aW9uSGFuZGxlciwgdXNlQ2xhc3M6IEZha2VNaXNzaW5nVHJhbnNsYXRpb25IYW5kbGVyIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBUcmFuc2xhdGVTdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogVVNFX1NUT1JFLCB1c2VWYWx1ZTogY29uZmlnLmlzb2xhdGUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogVVNFX0RFRkFVTFRfTEFORywgdXNlVmFsdWU6IGNvbmZpZy51c2VEZWZhdWx0TGFuZyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNsYXRlU2VydmljZVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgdGhpcyBtZXRob2QgaW4geW91ciBvdGhlciAobm9uIHJvb3QpIG1vZHVsZXMgdG8gaW1wb3J0IHRoZSBkaXJlY3RpdmUvcGlwZVxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZSB0aGlzIG1ldGhvZCBpbiB5b3VyIG90aGVyIChub24gcm9vdCkgbW9kdWxlcyB0byBpbXBvcnQgdGhlIGRpcmVjdGl2ZS9waXBlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGNvbmZpZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVHJhbnNsYXRlTW9kdWxlLmZvckNoaWxkID0gLyoqXG4gICAgICAgICAqIFVzZSB0aGlzIG1ldGhvZCBpbiB5b3VyIG90aGVyIChub24gcm9vdCkgbW9kdWxlcyB0byBpbXBvcnQgdGhlIGRpcmVjdGl2ZS9waXBlXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGNvbmZpZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5nTW9kdWxlOiBUcmFuc2xhdGVNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmxvYWRlciB8fCB7IHByb3ZpZGU6IFRyYW5zbGF0ZUxvYWRlciwgdXNlQ2xhc3M6IFRyYW5zbGF0ZUZha2VMb2FkZXIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5jb21waWxlciB8fCB7IHByb3ZpZGU6IFRyYW5zbGF0ZUNvbXBpbGVyLCB1c2VDbGFzczogVHJhbnNsYXRlRmFrZUNvbXBpbGVyIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcucGFyc2VyIHx8IHsgcHJvdmlkZTogVHJhbnNsYXRlUGFyc2VyLCB1c2VDbGFzczogVHJhbnNsYXRlRGVmYXVsdFBhcnNlciB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLm1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXIgfHwgeyBwcm92aWRlOiBNaXNzaW5nVHJhbnNsYXRpb25IYW5kbGVyLCB1c2VDbGFzczogRmFrZU1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogVVNFX1NUT1JFLCB1c2VWYWx1ZTogY29uZmlnLmlzb2xhdGUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogVVNFX0RFRkFVTFRfTEFORywgdXNlVmFsdWU6IGNvbmZpZy51c2VEZWZhdWx0TGFuZyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNsYXRlU2VydmljZVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIFRyYW5zbGF0ZU1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBjb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNsYXRlUGlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFuc2xhdGVEaXJlY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNsYXRlUGlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFuc2xhdGVEaXJlY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH1cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIFRyYW5zbGF0ZU1vZHVsZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gICAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzLGV4dHJhUmVxdWlyZSx1c2VsZXNzQ29kZX0gY2hlY2tlZCBieSB0c2NcbiAgICAgKi9cblxuICAgIGV4cG9ydHMuVHJhbnNsYXRlTW9kdWxlID0gVHJhbnNsYXRlTW9kdWxlO1xuICAgIGV4cG9ydHMuVHJhbnNsYXRlTG9hZGVyID0gVHJhbnNsYXRlTG9hZGVyO1xuICAgIGV4cG9ydHMuVHJhbnNsYXRlRmFrZUxvYWRlciA9IFRyYW5zbGF0ZUZha2VMb2FkZXI7XG4gICAgZXhwb3J0cy5VU0VfU1RPUkUgPSBVU0VfU1RPUkU7XG4gICAgZXhwb3J0cy5VU0VfREVGQVVMVF9MQU5HID0gVVNFX0RFRkFVTFRfTEFORztcbiAgICBleHBvcnRzLlRyYW5zbGF0ZVNlcnZpY2UgPSBUcmFuc2xhdGVTZXJ2aWNlO1xuICAgIGV4cG9ydHMuTWlzc2luZ1RyYW5zbGF0aW9uSGFuZGxlciA9IE1pc3NpbmdUcmFuc2xhdGlvbkhhbmRsZXI7XG4gICAgZXhwb3J0cy5GYWtlTWlzc2luZ1RyYW5zbGF0aW9uSGFuZGxlciA9IEZha2VNaXNzaW5nVHJhbnNsYXRpb25IYW5kbGVyO1xuICAgIGV4cG9ydHMuVHJhbnNsYXRlUGFyc2VyID0gVHJhbnNsYXRlUGFyc2VyO1xuICAgIGV4cG9ydHMuVHJhbnNsYXRlRGVmYXVsdFBhcnNlciA9IFRyYW5zbGF0ZURlZmF1bHRQYXJzZXI7XG4gICAgZXhwb3J0cy5UcmFuc2xhdGVDb21waWxlciA9IFRyYW5zbGF0ZUNvbXBpbGVyO1xuICAgIGV4cG9ydHMuVHJhbnNsYXRlRmFrZUNvbXBpbGVyID0gVHJhbnNsYXRlRmFrZUNvbXBpbGVyO1xuICAgIGV4cG9ydHMuVHJhbnNsYXRlRGlyZWN0aXZlID0gVHJhbnNsYXRlRGlyZWN0aXZlO1xuICAgIGV4cG9ydHMuVHJhbnNsYXRlUGlwZSA9IFRyYW5zbGF0ZVBpcGU7XG4gICAgZXhwb3J0cy5UcmFuc2xhdGVTdG9yZSA9IFRyYW5zbGF0ZVN0b3JlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiJdfQ==