"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DiffType;
(function (DiffType) {
    DiffType["Deleted"] = "JsonPropertyDeleted";
    DiffType["Added"] = "JsonPropertyAdded";
    DiffType["Modified"] = "JsonPropertyModified";
})(DiffType = exports.DiffType || (exports.DiffType = {}));
function isJsonChange(change) {
    return (change.type === DiffType.Added ||
        change.type === DiffType.Deleted ||
        change.type === DiffType.Modified);
}
exports.isJsonChange = isJsonChange;
function jsonDiff(lhs, rhs) {
    const result = [];
    const seenInLhs = new Set();
    walkJsonTree(lhs, [], (path, lhsValue) => {
        seenInLhs.add(hashArray(path));
        if (typeof lhsValue === 'object') {
            return true;
        }
        const rhsValue = getJsonValue(path, rhs);
        if (rhsValue === undefined) {
            result.push({
                type: DiffType.Deleted,
                path,
                value: {
                    lhs: lhsValue,
                    rhs: undefined
                }
            });
        }
        else if (lhsValue !== rhsValue) {
            result.push({
                type: DiffType.Modified,
                path,
                value: {
                    lhs: lhsValue,
                    rhs: rhsValue
                }
            });
        }
        return false;
    });
    walkJsonTree(rhs, [], (path, rhsValue) => {
        if (typeof rhsValue === 'object') {
            return true;
        }
        const addedInRhs = !seenInLhs.has(hashArray(path));
        if (addedInRhs) {
            result.push({
                type: DiffType.Added,
                path,
                value: {
                    lhs: undefined,
                    rhs: rhsValue
                }
            });
            return false;
        }
    });
    return result;
}
exports.jsonDiff = jsonDiff;
// Depth-first walk down JSON tree.
function walkJsonTree(json, currPath, visitor) {
    if (!json || typeof json !== 'object') {
        return;
    }
    Object.keys(json).forEach(key => {
        const path = currPath.concat([key]);
        const shouldContinue = visitor(path, json[key]);
        if (shouldContinue) {
            walkJsonTree(json[key], path, visitor);
        }
    });
}
exports.walkJsonTree = walkJsonTree;
function hashArray(ary) {
    return JSON.stringify(ary);
}
function getJsonValue(path, json) {
    let curr = json;
    for (const k of path) {
        curr = curr[k];
        if (curr === undefined) {
            break;
        }
    }
    return curr;
}
